<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slide2</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <!-- Marked.js for robust markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <!-- DOMPurify for sanitizing HTML -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <!-- html-docx-js for DOCX export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-docx-js/0.4.1/html-docx.min.js"></script>
    <!-- Showdown for enhanced markdown conversion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
    <!-- Add html2canvas and jsPDF libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2pdf library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <!-- File conversion libraries for Office files -->
    <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        :root {
            /* Night Theme (default) */
            --bg: #0a0a0a;
            --card: #1a1a1a;
            --text: #ffffff;
            --text-secondary: #a1a1aa;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --border: #2a2a2a;
            --scrollbar-track: #1a1a1a;
            --scrollbar-thumb: #404040;
            --modal-bg: #1a1a1a;
            --modal-border: #2a2a2a;
            --modal-text: #ffffff;
            --input-bg: #262626;
            --input-text: #ffffff;
            --input-border: #404040;
            --ai-bg: #0f0f0f;
            --ai-text: #ffffff;
            --ai-border: #2a2a2a;
            --sidebar-bg: #0a0a0a;
            --sidebar-icon: #a1a1aa;
            --success: #10b981;
            --success-hover: #059669;
            --danger: #ef4444;
            --danger-hover: #dc2626;
            --warning: #f59e0b;
            --warning-hover: #d97706;
            --muted: #6b7280;
            --hover: #262626;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.4);
            --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.5);
            --gradient-primary: linear-gradient(135deg, #3b82f6, #2563eb);
            --gradient-success: linear-gradient(135deg, #10b981, #059669);
            --gradient-danger: linear-gradient(135deg, #ef4444, #dc2626);
        }
        /* Night theme class (same as root) */
        .theme-night {
            /* Inherits from :root */
        }
        .theme-light {
            --bg: #fafafa;
            --card: #ffffff;
            --text: #111827;
            --text-secondary: #6b7280;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --border: #d1d5db;
            --scrollbar-track: #f3f4f6;
            --scrollbar-thumb: #9ca3af;
            --modal-bg: #ffffff;
            --modal-border: #d1d5db;
            --modal-text: #111827;
            --input-bg: #ffffff;
            --input-text: #111827;
            --input-border: #9ca3af;
            --ai-bg: #f8fafc;
            --ai-text: #111827;
            --ai-border: #d1d5db;
            --sidebar-bg: #ffffff;
            --sidebar-icon: #6b7280;
            --success: #10b981;
            --success-hover: #059669;
            --danger: #ef4444;
            --danger-hover: #dc2626;
            --warning: #f59e0b;
            --warning-hover: #d97706;
            --muted: #6b7280;
            --hover: #f1f5f9;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.15);
            --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.2);
            --gradient-primary: linear-gradient(135deg, #3b82f6, #2563eb);
            --gradient-success: linear-gradient(135deg, #10b981, #059669);
            --gradient-danger: linear-gradient(135deg, #ef4444, #dc2626);
        }
        .theme-dim {
            --bg: #1a1d21;
            --card: #23272f;
            --text: #e5e7eb;
            --text-secondary: #9ca3af;
            --accent: #60a5fa;
            --accent-hover: #3b82f6;
            --border: #2d3748;
            --scrollbar-track: #23272f;
            --scrollbar-thumb: #4a5568;
            --modal-bg: #23272f;
            --modal-border: #2d3748;
            --modal-text: #e5e7eb;
            --input-bg: #2d3748;
            --input-text: #e5e7eb;
            --input-border: #4a5568;
            --ai-bg: #1a1d21;
            --ai-text: #e5e7eb;
            --ai-border: #2d3748;
            --sidebar-bg: #1a1d21;
            --sidebar-icon: #9ca3af;
            --success: #10b981;
            --success-hover: #059669;
            --danger: #ef4444;
            --danger-hover: #dc2626;
            --warning: #f59e0b;
            --warning-hover: #d97706;
            --muted: #6b7280;
            --hover: #2d3748;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.3);
            --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.4);
            --gradient-primary: linear-gradient(135deg, #60a5fa, #3b82f6);
            --gradient-success: linear-gradient(135deg, #10b981, #059669);
            --gradient-danger: linear-gradient(135deg, #ef4444, #dc2626);
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* Smooth theme transitions */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .main-layout {
            display: flex;
            height: 100vh;
            background-color: var(--bg);
        }
        .sidebar {
            width: 280px;
            background-color: var(--sidebar-bg);
            border-right: 2px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            gap: 1.5rem;
            overflow-y: auto;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(10px);
        }
        .sidebar-collapsed {
            width: 0;
            padding: 0;
            border-right: none;
            overflow: hidden;
        }
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        .chat-header {
            background-color: var(--card);
            padding: 1.25rem 2rem;
            border-bottom: 2px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .toggle-sidebar-btn,
        .settings-btn,
        .export-btn {
            background: none;
            border: none;
            color: var(--sidebar-icon);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.75rem;
            border-radius: 0.75rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
            min-height: 44px;
        }
        .toggle-sidebar-btn:hover,
        .settings-btn:hover,
        .export-btn:hover {
            background-color: var(--hover);
            color: var(--text);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        .chat-title {
            font-size: 1.375rem;
            font-weight: 700;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            letter-spacing: -0.025em;
        }
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            scroll-behavior: smooth;
        }
        /* Custom Scrollbars */
        ::-webkit-scrollbar {
            width: 10px;
            background: var(--scrollbar-track);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 6px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }
        .sidebar::-webkit-scrollbar,
        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }
        .sidebar::-webkit-scrollbar-thumb,
        .chat-messages::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
        }
        .sidebar::-webkit-scrollbar-thumb:hover,
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }
        /* Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }
        .message-wrapper {
            margin-bottom: 2rem;
        }
        .message-wrapper:last-child {
            margin-bottom: 1rem;
        }
        .message-bubble {
            max-width: 100%;
            padding: 0;
            border-radius: 0.75rem;
            word-wrap: break-word;
            position: relative;
        }
        
        .message-actions {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transition: all 0.3s ease;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 0.5rem;
            backdrop-filter: blur(12px);
            box-shadow: var(--shadow-lg);
        }
        
        .message-bubble:hover .message-actions {
            opacity: 1;
        }
        
        .message-action-btn {
            background: transparent;
            border: none;
            color: var(--sidebar-icon);
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
            min-height: 36px;
        }
        
        .message-action-btn:hover {
            background: var(--hover);
            color: var(--text);
            transform: scale(1.1);
            box-shadow: var(--shadow-sm);
        }
        
        .message-action-btn:active {
            transform: scale(0.95);
        }
        
        .message-edit-input {
            width: 100%;
            background: var(--input-bg);
            color: var(--input-text);
            border: 2px solid var(--accent);
            border-radius: 0.75rem;
            padding: 1rem;
            font-size: 1rem;
            outline: none;
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
            line-height: 1.5;
            transition: all 0.2s ease;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            margin-bottom: 0.5rem;
        }
        
        .message-edit-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
        }
        
        .message-edit-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
            margin-top: 0.75rem;
        }
        .user-message {
            background-color: #2563eb;
            color: white;
            padding: 1rem 1.25rem;
            margin-left: auto;
            margin-right: 0;
            max-width: 70%;
            border-bottom-right-radius: 0.25rem;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .ai-message {
            background-color: var(--ai-bg);
            color: var(--ai-text);
            padding: 1.25rem;
            margin-left: 0;
            margin-right: 0;
            border: 1px solid var(--ai-border);
            border-bottom-left-radius: 0.25rem;
        }
        .message-content {
            line-height: 1.6;
        }
        .message-content p {
            margin: 0 0 1rem 0;
        }
        .message-content p:last-child {
            margin-bottom: 0;
        }
        .message-content h1,
        .message-content h2,
        .message-content h3,
        .message-content h4,
        .message-content h5,
        .message-content h6 {
            margin: 2rem 0 1rem 0;
            font-weight: 600;
            color: var(--ai-text);
            line-height: 1.3;
        }
        .message-content h1 {
            font-size: 1.75rem;
            margin-top: 2.5rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0.5rem;
        }
        .message-content h2 {
            font-size: 1.5rem;
            margin-top: 2rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.3rem;
        }
        .message-content h3 {
            font-size: 1.25rem;
            margin-top: 1.75rem;
        }
        .message-content h4 {
            font-size: 1.125rem;
            margin-top: 1.5rem;
        }
        .message-content h5,
        .message-content h6 {
            font-size: 1rem;
            margin-top: 1.25rem;
        }
        .message-content ul,
        .message-content ol {
            margin: 1rem 0;
            padding-left: 1.5rem;
            list-style-position: outside;
        }
        .message-content ul {
            list-style-type: disc;
        }
        .message-content ul ul {
            list-style-type: circle;
            margin: 0.5rem 0;
        }
        .message-content ul ul ul {
            list-style-type: square;
        }
        .message-content ol {
            counter-reset: item;
            list-style-type: none;
        }
        .message-content ol > li {
            counter-increment: item;
            display: block;
        }
        .message-content ol > li::before {
            content: counter(item) ". ";
            font-weight: bold;
        }
        .message-content ol ol {
            counter-reset: subitem;
            list-style-type: none;
        }
        .message-content ol ol > li {
            counter-increment: subitem;
            display: block;
        }
        .message-content ol ol > li::before {
            content: counter(item) "." counter(subitem) ". ";
            font-weight: bold;
        }
        .message-content ol ol ol {
            counter-reset: subsubitem;
            list-style-type: none;
        }
        .message-content ol ol ol > li {
            counter-increment: subsubitem;
            display: block;
        }
        .message-content ol ol ol > li::before {
            content: counter(item) "." counter(subitem) "." counter(subsubitem) ". ";
            font-weight: bold;
        }
        .message-content ul ul {
            list-style-type: circle;
            margin: 0.5rem 0;
        }
        .message-content ul ul ul {
            list-style-type: square;
        }
        .message-content li {
            margin: 0.5rem 0;
            padding-left: 0.5rem;
            line-height: 1.5;
        }
        .message-content li > p {
            margin: 0;
            display: inline;
        }
        .message-content .task-list-item {
            list-style: none;
            padding-left: 0;
        }
        .message-content .task-list-item input[type="checkbox"] {
            margin-right: 0.5rem;
            vertical-align: middle;
        }
        .message-content .task-list-item input[type="checkbox"]:checked {
            accent-color: var(--accent);
        }
        .message-content p {
            margin: 0.75rem 0;
            line-height: 1.6;
        }
        .message-content hr {
            border: none;
            height: 2px;
            background: linear-gradient(to right, transparent, var(--accent), transparent);
            margin: 2.5rem 0;
            border-radius: 1px;
            opacity: 0.8;
            position: relative;
        }
        
        .message-content hr::before {
            content: '';
            position: absolute;
            top: -1px;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(to right, transparent, var(--accent), transparent);
            border-radius: 2px;
            opacity: 0.3;
        }
        .message-content .table-container {
            margin: 1.5rem 0;
            overflow-x: auto;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
        }
        .message-content table {
            width: 100%;
            border-collapse: collapse;
            background-color: var(--card);
            font-size: 0.9rem;
        }
        .message-content table th {
            background-color: var(--border);
            color: var(--text);
            font-weight: 600;
            padding: 0.75rem 1rem;
            border-bottom: 2px solid var(--ai-border);
            text-align: left;
        }
        .message-content table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            color: var(--text);
        }
        .message-content table tr:hover {
            background-color: rgba(37, 99, 235, 0.05);
        }
        .message-content table tr:last-child td {
            border-bottom: none;
        }
        .message-content blockquote {
            border-left: 4px solid var(--accent);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            color: var(--ai-text);
            font-style: italic;
            background-color: rgba(37, 99, 235, 0.05);
            border-radius: 0.5rem;
            position: relative;
        }
        .message-content blockquote::before {
            content: '"';
            font-size: 3rem;
            color: var(--accent);
            position: absolute;
            top: -0.5rem;
            left: 0.5rem;
            opacity: 0.3;
        }
        .message-content blockquote blockquote {
            margin: 1rem 0;
            border-left: 3px solid var(--accent);
            background-color: rgba(37, 99, 235, 0.03);
        }
        .message-content blockquote blockquote::before {
            content: '"';
            font-size: 2rem;
            color: var(--accent);
            position: absolute;
            top: -0.3rem;
            left: 0.3rem;
            opacity: 0.2;
        }
        
        /* Admonitions/Callouts */
        .message-content .admonition {
            border-radius: 0.75rem;
            margin: 1.5rem 0;
            overflow: hidden;
            border: 1px solid;
            position: relative;
        }
        
        .message-content .admonition-header {
            padding: 0.75rem 1rem;
            font-weight: 600;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .message-content .admonition-content {
            padding: 0 1rem 1rem 1rem;
            line-height: 1.6;
        }
        
        .message-content .admonition-content p {
            margin: 0.5rem 0;
        }
        
        .message-content .admonition-content p:first-child {
            margin-top: 0;
        }
        
        .message-content .admonition-content p:last-child {
            margin-bottom: 0;
        }
        
        /* Admonition types - using data attributes for better browser support */
        .message-content .admonition.tip {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(34, 197, 94, 0.05) 100%);
            border-color: rgba(34, 197, 94, 0.3);
        }
        
        .message-content .admonition.tip .admonition-header {
            background: rgba(34, 197, 94, 0.15);
            color: #16a34a;
        }
        
        .message-content .admonition.warning {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(245, 158, 11, 0.05) 100%);
            border-color: rgba(245, 158, 11, 0.3);
        }
        
        .message-content .admonition.warning .admonition-header {
            background: rgba(245, 158, 11, 0.15);
            color: #d97706;
        }
        
        .message-content .admonition.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%);
            border-color: rgba(239, 68, 68, 0.3);
        }
        
        .message-content .admonition.error .admonition-header {
            background: rgba(239, 68, 68, 0.15);
            color: #dc2626;
        }
        
        .message-content .admonition.success {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(34, 197, 94, 0.05) 100%);
            border-color: rgba(34, 197, 94, 0.3);
        }
        
        .message-content .admonition.success .admonition-header {
            background: rgba(34, 197, 94, 0.15);
            color: #16a34a;
        }
        
        .message-content .admonition.info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%);
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        .message-content .admonition.info .admonition-header {
            background: rgba(59, 130, 246, 0.15);
            color: #2563eb;
        }
        
        /* Escaped characters */
        .message-content .escaped-char {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background-color: var(--border);
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-size: 0.875em;
            color: var(--accent);
        }
        .message-content strong {
            font-weight: 600;
            color: var(--ai-text);
        }
        .message-content em {
            font-style: italic;
            color: var(--ai-text);
            opacity: 0.9;
        }
        .message-content strong {
            font-weight: 600;
            color: var(--ai-text);
        }
        .message-content strong em,
        .message-content em strong {
            font-weight: 600;
            font-style: italic;
            color: var(--ai-text);
        }
        .message-content del {
            text-decoration: line-through;
            color: var(--ai-text);
            opacity: 0.6;
        }
        .message-content code {
            background-color: var(--border);
            color: var(--ai-text);
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875em;
        }
        .code-block {
            background-color: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 0.75rem;
            margin: 1.5rem 0;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .code-header {
            background: linear-gradient(135deg, #2d2d30 0%, #252526 100%);
            padding: 0.875rem 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #3e3e42;
            font-size: 0.875rem;
            border-radius: 0.75rem 0.75rem 0 0;
        }
        .code-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .code-language {
            font-size: 0.875rem;
            font-weight: 500;
            color: #cccccc;
            text-transform: uppercase;
        }
        .code-filename {
            font-size: 0.875rem;
            color: #60a5fa;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        .copy-btn {
            background-color: #3e3e42;
            color: #cccccc;
            border: none;
            padding: 0.375rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .copy-btn:hover {
            background-color: #007acc;
            color: white;
        }
        .copy-btn.copied {
            background-color: #059669;
            color: white;
        }
        .code-content {
            padding: 1rem;
            overflow-x: auto;
            background-color: #1e1e1e;
            border-radius: 0 0 0.75rem 0.75rem;
        }
        .code-content pre {
            margin: 0;
            padding: 0;
            background: transparent;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            white-space: pre;
            overflow-x: auto;
            tab-size: 4;
        }
        .code-content code {
            background: transparent;
            color: #d4d4d4;
            padding: 0;
            border-radius: 0;
            font-size: inherit;
        }
        
        /* Syntax highlighting colors - VS Code Dark theme style */
        .code-content .token.comment,
        .code-content .token.prolog,
        .code-content .token.doctype,
        .code-content .token.cdata {
            color: #6a9955;
        }
        
        .code-content .token.punctuation {
            color: #d4d4d4;
        }
        
        .code-content .token.property,
        .code-content .token.tag,
        .code-content .token.boolean,
        .code-content .token.number,
        .code-content .token.constant,
        .code-content .token.symbol,
        .code-content .token.deleted {
            color: #b5cea8;
        }
        
        .code-content .token.selector,
        .code-content .token.attr-name,
        .code-content .token.string,
        .code-content .token.char,
        .code-content .token.builtin,
        .code-content .token.inserted {
            color: #ce9178;
        }
        
        .code-content .token.operator,
        .code-content .token.entity,
        .code-content .token.url,
        .language-css .token.string,
        .style .token.string {
            color: #d4d4d4;
        }
        
        .code-content .token.atrule,
        .code-content .token.attr-value,
        .code-content .token.keyword {
            color: #c586c0;
        }
        
        .code-content .token.function,
        .code-content .token.class-name {
            color: #dcdcaa;
        }
        
        .code-content .token.regex,
        .code-content .token.important,
        .code-content .token.variable {
            color: #d16969;
        }
        
        .code-content .token.important,
        .code-content .token.bold {
            font-weight: bold;
        }
        
        .code-content .token.italic {
            font-style: italic;
        }
        
        .code-content .token.entity {
            cursor: help;
        }
        .new-chat-btn {
            background: var(--gradient-primary);
            color: white;
            padding: 0.75rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            height: 44px;
            min-width: 44px;
        }
        .new-chat-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .temp-chat-btn {
            background-color: var(--card);
            color: var(--text);
            border: 2px solid var(--border);
            padding: 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
            height: 44px;
            min-width: 44px;
        }
        
        .temp-chat-btn:hover {
            background-color: var(--hover);
            border-color: var(--accent);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        /* Temporary chat title styling */
        .chat-title[data-temp="true"] {
            color: var(--warning);
            font-style: italic;
        }

        /* Light theme specific enhancements */
        .theme-light .sidebar {
            background-color: #ffffff;
            border-right: 2px solid #d1d5db;
        }

        .theme-light .chat-header {
            background-color: #ffffff;
            border-bottom: 2px solid #d1d5db;
        }

        .theme-light .chat-input-area {
            background-color: #ffffff;
            border-top: 2px solid #d1d5db;
        }

        .theme-light .chat-item:hover {
            background-color: #f8fafc;
            border-color: #d1d5db;
        }

        .theme-light .search-input,
        .theme-light .chat-input {
            border: 2px solid #9ca3af;
        }

        .theme-light .search-input:focus,
        .theme-light .chat-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .theme-light .temp-chat-btn,
        .theme-light .import-btn {
            border: 2px solid #d1d5db;
            background-color: #ffffff;
        }

        .theme-light .temp-chat-btn:hover,
        .theme-light .import-btn:hover {
            border-color: #3b82f6;
            background-color: #f8fafc;
        }
        
        .import-btn {
            background-color: var(--card);
            color: var(--text);
            border: 2px solid var(--border);
            padding: 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
            height: 44px;
            min-width: 44px;
        }
        
        .import-btn:hover {
            background-color: var(--hover);
            border-color: var(--accent);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        .search-container {
            margin-bottom: 1rem;
        }
        
        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .search-icon {
            position: absolute;
            left: 0.75rem;
            color: var(--sidebar-icon);
            pointer-events: none;
        }
        
        .search-input {
            width: 100%;
            background-color: var(--input-bg);
            color: var(--input-text);
            border: 2px solid var(--input-border);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            font-size: 0.9rem;
            outline: none;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }
        
        .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }
        
        .search-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15), var(--shadow-md);
        }
        
        .clear-search-btn {
            position: absolute;
            right: 0.5rem;
            background: none;
            border: none;
            color: var(--sidebar-icon);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: all 0.2s ease;
        }
        
        .clear-search-btn:hover {
            color: var(--text);
            background-color: var(--border);
        }
        
        .chat-list {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .chat-item {
            background-color: transparent;
            padding: 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--sidebar-icon);
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            font-weight: 400;
            min-height: 36px;
            border: 1px solid transparent;
        }

        .chat-item .chat-title {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: calc(100% - 50px); /* Reserve space for action buttons */
            font-size: 0.8rem;
            font-weight: 400;
        }
        .chat-item:hover {
            background-color: var(--hover);
            color: var(--text);
            transform: translateX(4px);
            border-color: var(--border);
        }
        .chat-item.active {
            background: var(--gradient-primary);
            color: white;
            box-shadow: var(--shadow-md);
        }
        .chat-actions {
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.2s;
            flex-shrink: 0;
            min-width: 50px;
        }
        .chat-item:hover .chat-actions,
        .chat-item.active .chat-actions {
            opacity: 1;
        }
        .chat-action-btn {
            background: none;
            border: none;
            color: var(--sidebar-icon);
            font-size: 0.9rem;
            cursor: pointer;
            padding: 0.375rem;
            border-radius: 0.375rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            min-height: 28px;
        }
        .chat-action-btn:hover {
            background-color: var(--hover);
            color: var(--text);
            transform: scale(1.1);
        }
        .chat-rename-input {
            background: var(--input-bg);
            color: var(--input-text);
            border: 1px solid var(--input-border);
            border-radius: 0.25rem;
            padding: 0.25rem 0.5rem;
            font-size: 0.9rem;
            width: 80%;
            outline: none;
        }
        .chat-delete-confirm {
            display: none;
        }
        .chat-delete-confirm-btns {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        .chat-delete-btn {
            background: #ef4444;
            color: #fff;
            border: none;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }
        .chat-delete-btn:hover {
            background: #dc2626;
        }
        .chat-cancel-btn {
            background: #23272f;
            color: #e3e3e3;
            border: 1px solid #374151;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }
        .chat-cancel-btn:hover {
            background: #262626;
        }
        .chat-input-area {
            background-color: var(--card);
            padding: 1.5rem 2rem;
            border-top: 2px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
        }
        .input-and-buttons {
            display: flex;
            width: 100%;
            gap: 1rem;
            align-items: flex-end;
        }
        .attach-file-btn {
            background: none;
            border: none;
            color: var(--sidebar-icon);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.875rem;
            border-radius: 0.875rem;
            transition: all 0.2s ease;
            min-width: 48px;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .attach-file-btn:hover {
            background-color: var(--hover);
            color: var(--text);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        .generate-image-btn {
            background: none;
            border: none;
            color: var(--sidebar-icon);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.875rem;
            border-radius: 0.875rem;
            transition: all 0.2s ease;
            min-width: 48px;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .generate-image-btn:hover {
            background-color: var(--hover);
            color: var(--text);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        .image-preview-container {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 0;
            overflow-x: auto;
            width: 100%;
            border-top: 1px solid var(--border);
            padding-top: 1rem;
            margin-top: 1rem;
        }
        .image-preview-item {
            position: relative;
            width: 100px;
            height: 100px;
            border-radius: 0.5rem;
            overflow: hidden;
            flex-shrink: 0;
            border: 1px solid var(--border);
            background: var(--card);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .image-preview-item img,
        .image-preview-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .image-preview-item audio {
            width: 90px;
            height: 30px;
        }
        .file-preview-icon {
            font-size: 2.2rem;
            color: var(--accent);
            margin-bottom: 0.2rem;
        }
        .file-preview-info {
            font-size: 0.8rem;
            color: var(--text);
            text-align: center;
            word-break: break-all;
            padding: 0 2px;
        }
        .image-preview-remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            line-height: 1;
            padding: 0;
        }
        .image-preview-remove:hover {
            background-color: rgba(255, 0, 0, 0.8);
        }
        .input-wrapper {
            flex: 1;
            position: relative;
            display: flex;
            align-items: flex-end;
        }
        .chat-input {
            width: 100%;
            background-color: var(--input-bg);
            color: var(--input-text);
            border: 2px solid var(--input-border);
            border-radius: 1rem;
            padding: 1rem 1.25rem;
            font-size: 1rem;
            line-height: 1.5;
            resize: none;
            outline: none;
            transition: all 0.2s ease;
            min-height: 48px;
            max-height: 120px;
            overflow-y: auto;
            white-space: pre-wrap;
            box-sizing: border-box;
            box-shadow: var(--shadow-sm);
        }
        .chat-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }
        
        .chat-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15), var(--shadow-md);
        }
        .send-btn {
            background: var(--gradient-primary);
            color: white;
            border: none;
            padding: 1rem 1.75rem;
            border-radius: 1rem;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            min-height: 48px;
            min-width: 90px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-md);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        .send-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        .send-btn:disabled {
            background: var(--muted);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            color: var(--text-secondary);
        }
        .loading-indicator {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: var(--sidebar-icon);
            font-style: italic;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--ai-bg);
            border: 1px solid var(--ai-border);
            border-radius: 0.75rem;
            border-bottom-left-radius: 0.25rem;
        }
        
        .file-upload-progress {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .progress-bar {
            flex: 1;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .upload-status {
            font-size: 0.875rem;
            color: var(--sidebar-icon);
        }



        .customize-btn:hover {
            background: var(--border);
            border-color: var(--accent);
        }

        /* Modern Settings Modal Styles */
        .settings-modal-content {
            background-color: var(--modal-bg);
            border: 1px solid var(--modal-border);
            border-radius: 1.5rem;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow: hidden;
            position: relative;
            color: var(--modal-text);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .settings-modal-header {
            padding: 2rem 2rem 1.5rem 2rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: var(--modal-bg);
        }

        .settings-header-content {
            flex: 1;
        }

        .settings-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            display: block;
        }

        .settings-title {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--modal-text);
            margin-bottom: 0.25rem;
            letter-spacing: -0.025em;
        }

        .settings-subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .settings-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem 2rem;
        }

        .settings-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            transition: all 0.2s ease;
        }

        .settings-section:hover {
            border-color: var(--accent);
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .settings-section:focus-within {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), var(--shadow-md);
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .section-icon {
            font-size: 1.25rem;
            width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--accent);
            color: white;
            border-radius: 0.5rem;
            font-weight: 600;
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text);
        }

        .section-content {
            margin-left: 2.75rem;
        }

        /* Modern Select Styles */
        .model-selector-wrapper {
            position: relative;
            margin-bottom: 1rem;
        }

        .modern-select {
            width: 100%;
            background: var(--input-bg);
            border: 2px solid var(--input-border);
            border-radius: 0.75rem;
            padding: 1rem 1.25rem;
            font-size: 1rem;
            color: var(--input-text);
            appearance: none;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .modern-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), var(--shadow-md);
        }

        .select-arrow {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            pointer-events: none;
            font-size: 0.8rem;
        }

        /* Model Info Styles */
        .model-info {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .info-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--ai-bg);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .info-item.warning {
            background: rgba(245, 158, 11, 0.1);
            border-color: rgba(245, 158, 11, 0.3);
        }

        .info-icon {
            font-size: 1rem;
            flex-shrink: 0;
            margin-top: 0.1rem;
        }
        .info-text {
            color: var(--text);
            flex: 1;
        }

        /* Timeout Control Styles */
        .timeout-control {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }

        .timeout-slider-wrapper {
            flex: 1;
            position: relative;
        }

        .modern-slider {
            width: 100%;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            outline: none;
            appearance: none;
            cursor: pointer;
        }

        .modern-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all 0.2s ease;
        }

        .modern-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: var(--shadow-lg);
        }

        .timeout-value {
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            color: var(--accent);
            font-size: 1.1rem;
        }

        .timeout-hint {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* API Key Input Styles */
        .api-key-wrapper {
            margin-bottom: 1rem;
        }

        .api-key-label {
            display: block;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .input-wrapper {
            position: relative;
        }

        .modern-input {
            width: 100%;
            background: var(--input-bg);
            border: 2px solid var(--input-border);
            border-radius: 0.75rem;
            padding: 1rem 1.25rem 1rem 3rem;
            font-size: 1rem;
            color: var(--input-text);
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .modern-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), var(--shadow-md);
        }

        .input-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            font-size: 1rem;
        }

        /* Theme Selector Styles */
        .theme-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        .theme-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .theme-option:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .theme-option.active {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.1);
        }

        .theme-preview {
            width: 3rem;
            height: 2rem;
            border-radius: 0.5rem;
            border: 2px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .night-preview {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
        }

        .dim-preview {
            background: linear-gradient(135deg, #1a1d21 0%, #23272f 100%);
        }

        .light-preview {
            background: linear-gradient(135deg, #fafafa 0%, #ffffff 100%);
        }

        .theme-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text);
        }

        /* Customization Button Styles */
        .customization-btn {
            width: 100%;
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .customization-btn:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn-content {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .btn-icon {
            font-size: 1.5rem;
            width: 3rem;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--accent);
            color: white;
            border-radius: 0.75rem;
        }

        .btn-text {
            flex: 1;
        }

        .btn-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 0.25rem;
        }

        .btn-subtitle {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .btn-arrow {
            font-size: 1.25rem;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .customization-btn:hover .btn-arrow {
            transform: translateX(4px);
            color: var(--accent);
        }

        /* Settings Modal Footer */
        .settings-modal-footer {
            padding: 1.5rem 2rem;
            border-top: 1px solid var(--border);
            background: var(--modal-bg);
        }

        .save-settings-btn {
            width: 100%;
            background: var(--gradient-primary);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            position: relative;
            overflow: hidden;
        }

        .save-settings-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .storage-info-btn:hover {
            background: var(--hover);
            color: var(--text);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }

        .save-settings-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .save-settings-btn.loading {
            pointer-events: none;
        }

        .save-settings-btn.loading .btn-text {
            opacity: 0;
        }

        .save-settings-btn.loading .btn-loading {
            opacity: 1;
        }

        .btn-loading {
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .btn-loading .loading-dot {
            width: 6px;
            height: 6px;
            background-color: currentColor;
            border-radius: 50%;
            animation: loading 1.4s ease-in-out infinite both;
        }

        .btn-loading .loading-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .btn-loading .loading-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes loading {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1);
            }
        }

        /* Modern Customization Modal Styles */
        .customization-modal-content {
            background-color: var(--modal-bg);
            border: 1px solid var(--modal-border);
            border-radius: 1.5rem;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow: hidden;
            position: relative;
            color: var(--modal-text);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .customization-modal-header {
            padding: 2rem 2rem 1.5rem 2rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: var(--modal-bg);
        }

        .customization-header-content {
            flex: 1;
        }

        .customization-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            display: block;
        }

        .customization-title {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--modal-text);
            margin-bottom: 0.25rem;
            letter-spacing: -0.025em;
        }

        .customization-subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .customization-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem 2rem;
        }

        .customization-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            transition: all 0.2s ease;
        }

        .customization-section:hover {
            border-color: var(--accent);
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .customization-section:focus-within {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), var(--shadow-md);
        }

        .input-group {
            margin-bottom: 1.5rem;
        }

        .input-group:last-child {
            margin-bottom: 0;
        }

        .modern-label {
            display: block;
            cursor: pointer;
        }

        .label-text {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text);
            margin-bottom: 0.75rem;
            display: block;
        }

        .textarea-wrapper {
            position: relative;
        }

        .modern-textarea {
            width: 100%;
            background: var(--input-bg);
            border: 2px solid var(--input-border);
            border-radius: 0.75rem;
            padding: 1rem 1.25rem 1rem 3rem;
            font-size: 1rem;
            color: var(--input-text);
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
            resize: vertical;
            min-height: 100px;
            font-family: inherit;
            line-height: 1.5;
        }

        .modern-textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), var(--shadow-md);
        }

        .textarea-icon {
            position: absolute;
            left: 1rem;
            top: 1rem;
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .input-hint {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            line-height: 1.4;
        }

        .personality-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            line-height: 1.5;
            padding: 0.75rem;
            background: var(--ai-bg);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
        }

        .traits-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .trait-option {
            display: block;
            cursor: pointer;
        }

        .trait-option input[type="checkbox"] {
            display: none;
        }

        .trait-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            border: 2px solid var(--border);
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--card);
            text-align: center;
        }

        .trait-option:hover .trait-content {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .trait-option:focus-within .trait-content {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), var(--shadow-md);
        }

        .trait-option input[type="checkbox"]:checked + .trait-content {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.1);
            box-shadow: var(--shadow-md);
        }

        .trait-icon {
            font-size: 1.5rem;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--accent);
            color: white;
            border-radius: 0.5rem;
        }

        .trait-text {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text);
        }

        .trait-option input[type="checkbox"]:checked + .trait-content .trait-text {
            color: var(--accent);
            font-weight: 600;
        }

        /* Customization Modal Footer */
        .customization-modal-footer {
            padding: 1.5rem 2rem;
            border-top: 1px solid var(--border);
            background: var(--modal-bg);
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        .cancel-customization-btn {
            padding: 0.75rem 1.5rem;
            background: none;
            border: 2px solid var(--border);
            border-radius: 0.75rem;
            color: var(--text);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .cancel-customization-btn:hover {
            background: var(--border);
            transform: translateY(-1px);
        }

        .save-customization-btn {
            padding: 0.75rem 1.5rem;
            background: var(--gradient-primary);
            border: none;
            border-radius: 0.75rem;
            color: white;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .save-customization-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .save-customization-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .save-customization-btn.loading {
            pointer-events: none;
        }

        .save-customization-btn.loading .btn-text {
            opacity: 0;
        }

        .save-customization-btn.loading .btn-loading {
            opacity: 1;
        }
        .loading-dots {
            display: flex;
            gap: 0.25rem;
        }
        .loading-dot {
            width: 6px;
            height: 6px;
            background-color: #9ca3af;
            border-radius: 50%;
            animation: loading 1.4s ease-in-out infinite both;
        }
        .loading-dot:nth-child(1) {
            animation-delay: -0.32s;
        }
        .loading-dot:nth-child(2) {
            animation-delay: -0.16s;
        }
        @keyframes loading {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1);
            }
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(0px);
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
            backdrop-filter: blur(4px);
        }

        /* Modal content animations */
        .settings-modal-content,
        .customization-modal-content {
            transform: scale(0.9) translateY(20px);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal-overlay.visible .settings-modal-content,
        .modal-overlay.visible .customization-modal-content {
            transform: scale(1) translateY(0);
            opacity: 1;
        }
        .modal-content {
            background-color: var(--modal-bg);
            border: 1px solid var(--modal-border);
            border-radius: 1.5rem;
            padding: 2.5rem;
            max-width: 500px;
            width: 90%;
            position: relative;
            color: var(--modal-text);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(10px);
        }
        .modal-header {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--modal-text);
            margin-bottom: 2rem;
            text-align: center;
            letter-spacing: -0.025em;
        }
        .modal-close {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            background: none;
            border: none;
            color: var(--sidebar-icon);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
            min-height: 44px;
        }
        .modal-close:hover {
            color: var(--text);
            background-color: var(--hover);
            transform: scale(1.1);
        }
        .modal-close:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        .api-key-input {
            width: 100%;
            background-color: var(--input-bg);
            color: var(--input-text);
            border: 2px solid var(--input-border);
            border-radius: 0.75rem;
            padding: 1rem 1.25rem;
            font-size: 1rem;
            margin-bottom: 1.5rem;
            outline: none;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }
        .api-key-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), var(--shadow-md);
        }
        .save-btn {
            background: var(--gradient-success);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-md);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        .save-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        /* Responsive Design */
        @media (max-width: 768px) { /* CONFIG.MOBILE_BREAKPOINT */
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 100;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }
            .sidebar.mobile-open {
                transform: translateX(0);
            }
            .sidebar-collapsed {
                transform: translateX(-100%);
            }
            .chat-container {
                width: 100%;
                margin-left: 0;
            }
            .user-message {
                max-width: 85%;
            }
            .chat-input-area {
                padding: 1rem;
            }
            .input-and-buttons {
                gap: 0.75rem;
            }
            .send-btn {
                padding: 0.75rem 1rem;
                min-width: 70px;
            }
            
            /* Modal responsive adjustments */
            .settings-modal-content,
            .customization-modal-content {
                width: 95%;
                max-width: none;
                margin: 1rem;
                max-height: 90vh;
            }
            
            .settings-modal-header,
            .customization-modal-header {
                padding: 1.5rem 1.5rem 1rem 1.5rem;
            }
            
            .settings-modal-body,
            .customization-modal-body {
                padding: 1rem 1.5rem;
            }
            
            .settings-modal-footer,
            .customization-modal-footer {
                padding: 1rem 1.5rem;
            }
            
            .settings-section,
            .customization-section {
                padding: 1rem;
                margin-bottom: 1.5rem;
            }
            
            .section-content {
                margin-left: 2rem;
            }
            
            .traits-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 0.5rem;
            }
            
            .theme-selector {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.75rem;
            }
            
            .theme-option {
                padding: 0.75rem;
            }
            
            .theme-preview {
                width: 2.5rem;
                height: 1.5rem;
            }
            
            .btn-content {
                gap: 0.75rem;
            }
            
            .btn-icon {
                width: 2.5rem;
                height: 2.5rem;
                font-size: 1.25rem;
            }
        }
        @media (max-width: 480px) {
            .chat-header {
                padding: 1rem;
            }
            .chat-messages {
                padding: 0.75rem;
            }
            .user-message {
                max-width: 90%;
            }
            .ai-message {
                padding: 1rem;
            }
            .chat-input-area {
                padding: 0.75rem;
                gap: 0.75rem;
            }
            .input-and-buttons {
                gap: 0.5rem;
            }
            .send-btn {
                padding: 0.75rem 0.75rem;
                min-width: 60px;
            }
            .attach-file-btn {
                padding: 0.75rem;
                min-width: 40px;
                min-height: 40px;
            }
            
            /* Extra small screen modal adjustments */
            .settings-modal-content,
            .customization-modal-content {
                width: 98%;
                margin: 0.5rem;
                max-height: 95vh;
            }
            
            .settings-modal-header,
            .customization-modal-header {
                padding: 1rem 1rem 0.75rem 1rem;
            }
            
            .settings-modal-body,
            .customization-modal-body {
                padding: 0.75rem 1rem;
            }
            
            .settings-modal-footer,
            .customization-modal-footer {
                padding: 0.75rem 1rem;
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .settings-section,
            .customization-section {
                padding: 0.75rem;
                margin-bottom: 1rem;
            }
            
            .section-content {
                margin-left: 1.5rem;
            }
            
            .traits-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
            }
            
            .trait-content {
                padding: 0.75rem;
            }
            
            .trait-icon {
                width: 2rem;
                height: 2rem;
                font-size: 1.25rem;
            }
            
            .theme-selector {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.5rem;
            }
            
            .theme-option {
                padding: 0.5rem;
            }
            
            .theme-preview {
                width: 2rem;
                height: 1.25rem;
            }
            
            .btn-content {
                gap: 0.5rem;
            }
            
            .btn-icon {
                width: 2rem;
                height: 2rem;
                font-size: 1rem;
            }
            
            .btn-title {
                font-size: 1rem;
            }
            
            .btn-subtitle {
                font-size: 0.8rem;
            }
        }
        .theme-btn {
            background: var(--card);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 0.4rem;
            padding: 0.4rem 1.1rem;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 500;
            margin-bottom: 0.2rem;
            transition: background 0.2s, color 0.2s, border 0.2s;
        }
        .theme-btn.active, .theme-btn:focus {
            background: var(--accent);
            color: #fff;
            border: 1.5px solid var(--accent-hover);
        }
        .theme-btn:hover {
            background: var(--accent-hover);
            color: #fff;
        }
        /* Add styles for attached files in user prompts */
        .attached-files-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .attached-file-item {
            display: flex;
            align-items: center;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.4rem;
            padding: 0.2rem 0.6rem 0.2rem 0.3rem;
            font-size: 0.92em;
            color: var(--text);
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }
        .attached-file-item .file-preview-icon {
            font-size: 1.2em;
            margin-right: 0.4em;
        }
        .attached-file-info {
            font-size: 0.95em;
            color: var(--text);
        }

        /* Image Generation Modal Styles */
        .image-generation-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .image-generation-modal.visible {
            display: flex;
        }

        .image-generation-content {
            background: var(--card);
            border-radius: 1.5rem;
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .image-generation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border);
            background: var(--card);
        }

        .image-generation-header h3 {
            margin: 0;
            color: #111827;
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            letter-spacing: -0.025em;
        }

        /* Dark theme overrides for header */
        .theme-night .image-generation-header h3,
        .theme-dim .image-generation-header h3 {
            color: #f9fafb;
        }

        .image-generation-header h3::before {
            content: "";
            font-size: 1.2rem;
        }

        .close-image-modal {
            background: none;
            border: none;
            color: #6b7280;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-image-modal:hover {
            background: #f3f4f6;
            color: #374151;
            transform: scale(1.1);
        }

        /* Dark theme overrides for close button */
        .theme-night .close-image-modal,
        .theme-dim .close-image-modal {
            color: #9ca3af;
        }

        .theme-night .close-image-modal:hover,
        .theme-dim .close-image-modal:hover {
            background: #374151;
            color: #f9fafb;
        }

        .image-generation-body {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .image-generation-left {
            flex: 1;
            padding: 2rem;
            border-right: 1px solid var(--border);
            overflow-y: auto;
        }

        .image-generation-right {
            flex: 1;
            padding: 2rem;
            background: var(--background);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
        }

        .image-prompt-section {
            margin-bottom: 2rem;
        }

        .image-prompt-section label {
            display: block;
            margin-bottom: 0.75rem;
            color: #111827;
            font-weight: 700;
            font-size: 1rem;
            letter-spacing: -0.025em;
        }

        /* Dark theme overrides for labels */
        .theme-night .image-prompt-section label,
        .theme-dim .image-prompt-section label {
            color: #f9fafb;
        }

        .image-prompt-input {
            width: 100%;
            padding: 1rem;
            border: 2px solid #d1d5db;
            border-radius: 0.75rem;
            background: #ffffff;
            color: #111827;
            font-size: 1rem;
            resize: vertical;
            min-height: 120px;
            transition: all 0.2s;
            font-family: inherit;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .image-prompt-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1), 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Dark theme overrides for input */
        .theme-night .image-prompt-input,
        .theme-dim .image-prompt-input {
            background: #374151;
            color: #f9fafb;
            border-color: #4b5563;
        }

        .theme-night .image-prompt-input:focus,
        .theme-dim .image-prompt-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2), 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .reference-image-section {
            margin-bottom: 2rem;
        }

        .reference-image-section label {
            display: block;
            margin-bottom: 0.75rem;
            color: #111827;
            font-weight: 700;
            font-size: 1rem;
            letter-spacing: -0.025em;
        }

        /* Dark theme overrides for reference image labels */
        .theme-night .reference-image-section label,
        .theme-dim .reference-image-section label {
            color: #f9fafb;
        }

        .upload-reference-btn {
            background: var(--background);
            color: var(--text);
            border: 2px solid var(--border);
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .upload-reference-btn:hover {
            background: var(--hover);
            border-color: var(--accent);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .reference-image-preview {
            display: none;
            margin-top: 1rem;
            padding: 1rem;
            border: 2px solid #d1d5db;
            border-radius: 0.75rem;
            background: #f9fafb;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Dark theme overrides for reference image preview */
        .theme-night .reference-image-preview,
        .theme-dim .reference-image-preview {
            background: #374151;
            border-color: #4b5563;
        }

        .reference-image-preview.visible {
            display: block;
        }

        .reference-image-preview img {
            max-width: 100%;
            max-height: 200px;
            border-radius: 0.5rem;
            object-fit: cover;
        }

        .reference-image-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.75rem;
        }

        .reference-image-name {
            color: var(--text);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .remove-reference-btn {
            background: #dc2626;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(220, 38, 38, 0.3);
        }

        .remove-reference-btn:hover {
            background: #b91c1c;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(220, 38, 38, 0.4);
        }

        .image-generation-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1rem;
        }

        .generate-image-btn {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .generate-image-btn:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
        }

        .generate-image-btn:disabled {
            background: #6b7280;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            color: #d1d5db;
        }

        .cancel-image-btn {
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #d1d5db;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .cancel-image-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* Dark theme overrides for cancel button */
        .theme-night .cancel-image-btn {
            background: #374151;
            color: #f9fafb;
            border-color: #4b5563;
        }

        .theme-night .cancel-image-btn:hover {
            background: #4b5563;
            border-color: #6b7280;
        }

        .theme-dim .cancel-image-btn {
            background: #374151;
            color: #f9fafb;
            border-color: #4b5563;
        }

        .theme-dim .cancel-image-btn:hover {
            background: #4b5563;
            border-color: #6b7280;
        }

        .image-generation-result {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .image-generation-result.visible {
            display: flex;
        }

        .generated-image {
            max-width: 100%;
            max-height: 80%;
            border-radius: 1rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: 2px solid var(--border);
        }

        .image-result-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .download-image-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .download-image-btn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.5);
        }

        .regenerate-image-btn {
            background: #ffffff;
            color: #374151;
            border: 2px solid #d1d5db;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .regenerate-image-btn:hover {
            background: #f9fafb;
            border-color: #3b82f6;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* Dark theme overrides for regenerate button */
        .theme-night .regenerate-image-btn {
            background: #374151;
            color: #f9fafb;
            border-color: #4b5563;
        }

        .theme-night .regenerate-image-btn:hover {
            background: #4b5563;
            border-color: #3b82f6;
        }

        .theme-dim .regenerate-image-btn {
            background: #374151;
            color: #f9fafb;
            border-color: #4b5563;
        }

        .theme-dim .regenerate-image-btn:hover {
            background: #4b5563;
            border-color: #3b82f6;
        }

        .image-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            color: #374151;
            font-weight: 500;
        }

        /* Dark theme overrides for loading text */
        .theme-night .image-loading,
        .theme-dim .image-loading {
            color: #f9fafb;
        }

        .image-loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top: 3px solid var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .image-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            color: #6b7280;
            text-align: center;
            height: 100%;
        }

        .image-placeholder-icon {
            font-size: 4rem;
            opacity: 0.6;
        }

        .image-placeholder-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
        }

        .image-placeholder-subtext {
            font-size: 0.9rem;
            color: #6b7280;
            font-weight: 400;
        }

        /* Dark theme overrides for placeholder */
        .theme-night .image-placeholder,
        .theme-dim .image-placeholder {
            color: #9ca3af;
        }

        .theme-night .image-placeholder-text,
        .theme-dim .image-placeholder-text {
            color: #f9fafb;
        }

        .theme-night .image-placeholder-subtext,
        .theme-dim .image-placeholder-subtext {
            color: #9ca3af;
        }
        /* Responsive design for image generation modal */
        @media (max-width: 768px) {
            .image-generation-content {
                width: 95%;
                max-height: 95vh;
                margin: 1rem;
            }

            .image-generation-body {
                flex-direction: column;
            }

            .image-generation-left {
                border-right: none;
                border-bottom: 1px solid var(--border);
                padding: 1.5rem;
            }

            .image-generation-right {
                padding: 1.5rem;
                min-height: 300px;
            }

            .image-generation-header {
                padding: 1rem 1.5rem;
            }

            .image-generation-header h3 {
                font-size: 1.25rem;
            }

            .image-prompt-input {
                min-height: 100px;
            }

            .image-generation-actions {
                flex-direction: column;
            }

            .generate-image-btn,
            .cancel-image-btn {
                width: 100%;
            }
        }
        
        .model-indicator {
            font-size: 0.75rem;
            color: var(--sidebar-icon);
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border);
            font-style: italic;
        }
        .chat-options-menu {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.5em;
            box-shadow: 0 8px 32px rgba(0,0,0,0.18), 0 1.5px 4px rgba(0,0,0,0.08);
            min-width: 160px;
            z-index: 9999;
            padding: 0.3em 0;
            display: flex;
            flex-direction: column;
            gap: 0;
            font-size: 1em;
        }
        .chat-options-menu-item {
            background: none;
            border: none;
            text-align: left;
            padding: 0.85em 1.3em;
            cursor: pointer;
            font-size: 1em;
            color: var(--text);
            transition: background 0.15s, color 0.15s;
            border-radius: 0;
        }
        .chat-options-menu-item:hover {
            background: var(--border);
            color: var(--accent);
        }
        .chat-options-menu-item:last-child {
            border-bottom-left-radius: 0.5em;
            border-bottom-right-radius: 0.5em;
        }
        .chat-options-menu-item:first-child {
            border-top-left-radius: 0.5em;
            border-top-right-radius: 0.5em;
        }
        /* --- Code Popup Modal Styles --- */
        .code-modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s cubic-bezier(.4,0,.2,1);
        }
        .code-modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .code-modal {
            background: var(--card);
            border: 1.5px solid var(--border);
            border-radius: 1.1rem;
            box-shadow: 0 12px 48px 0 rgba(0,0,0,0.25), 0 1.5px 4px rgba(0,0,0,0.08);
            max-width: 96vw;
            min-width: 280px;
            width: 600px;
            max-height: 82vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            color: var(--text);
            animation: fadeInModal 0.25s cubic-bezier(.4,0,.2,1);
        }
        @keyframes fadeInModal {
            from { transform: translateY(40px) scale(0.98); opacity: 0; }
            to { transform: none; opacity: 1; }
        }
        .code-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem 0.5rem 1.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            border-bottom: 1px solid var(--border);
            background: var(--card);
        }
        .code-modal-close {
            background: none;
            border: none;
            color: var(--sidebar-icon);
            font-size: 1.5rem;
            cursor: pointer;
            border-radius: 0.3rem;
            transition: background 0.2s, color 0.2s;
        }
        .code-modal-close:hover {
            background: var(--border);
            color: var(--accent);
        }
        .code-modal-content {
            padding: 1.2rem 1.5rem 1.5rem 1.5rem;
            background: var(--ai-bg);
            overflow-x: auto;
            overflow-y: auto;
            flex: 1;
            font-size: 1.01rem;
            font-family: 'Menlo', 'Monaco', 'Consolas', 'Ubuntu Mono', monospace;
            border-bottom-left-radius: 1.1rem;
            border-bottom-right-radius: 1.1rem;
        }
        .code-modal-copy-btn {
            background: var(--border);
            color: var(--ai-text);
            border: none;
            padding: 0.4rem 1.1rem;
            border-radius: 0.4rem;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 500;
            margin-left: 1rem;
            transition: background 0.2s, color 0.2s;
        }
        .code-modal-copy-btn:hover {
            background: var(--accent);
            color: #fff;
        }
        .show-code-btn {
            background: var(--border);
            color: var(--accent);
            border: none;
            border-radius: 0.5em;
            padding: 0.45em 1.2em;
            font-size: 1em;
            font-weight: 500;
            margin: 0.5em 0 0.5em 0;
            cursor: pointer;
            box-shadow: 0 1.5px 4px rgba(0,0,0,0.04);
            transition: background 0.18s, color 0.18s, box-shadow 0.18s;
            display: inline-flex;
            align-items: center;
        }
        .show-code-btn:hover {
            background: var(--accent);
            color: #fff;
            box-shadow: 0 4px 16px rgba(37,99,235,0.10);
        }
        @media (max-width: 700px) {
            .code-modal { width: 99vw; min-width: 0; }
            .code-modal-content { padding: 1rem 0.5rem 1rem 0.5rem; }
        }
        
        /* Export Modal Styles */
        .export-format-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--input-bg);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }
        .export-format-option:hover {
            background: var(--border);
        }
        .export-format-option input[type="radio"] {
            margin: 0;
        }
        .export-format-option input[type="radio"]:checked + span {
            color: var(--accent);
            font-weight: 600;
        }
        .export-option-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .export-option-checkbox input[type="checkbox"] {
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="main-layout" id="mainLayout">
        <div class="sidebar" id="sidebar">
            <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem; height: 44px;">
                <button class="new-chat-btn" id="newChatBtn" style="flex: 1; height: 44px; min-width: 44px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 5v14M5 12h14"/>
                    </svg>
                </button>
                <button class="temp-chat-btn" id="tempChatBtn" title="Temporary Chat" aria-label="Temporary Chat" style="height: 44px; min-width: 44px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
                    </svg>
                </button>
                <button class="import-btn" id="importBtn" title="Import chats" aria-label="Import chats" style="height: 44px; min-width: 44px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7,10 12,15 17,10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                </button>
            </div>
            
            <!-- Search functionality -->
            <div class="search-container">
                <div class="search-input-wrapper">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="search-icon">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.35-4.35"/>
                    </svg>
                    <input type="text" id="chatSearchInput" class="search-input" placeholder="Search chats..." aria-label="Search chats">
                    <button id="clearSearchBtn" class="clear-search-btn" aria-label="Clear search" style="display: none;"></button>
                </div>
            </div>


            
            <div class="chat-list" id="chatList">
                <!-- Chat items will be populated here -->
            </div>

            <!-- Minimal Customization Section -->
            <div class="customization-section" style="margin-top: auto; padding-top: 1rem; border-top: 1px solid var(--border);">
                <button id="quickCustomizeBtn" class="customize-btn" style="width: 100%; padding: 0.75rem; background: none; border: 1px solid var(--border); border-radius: 0.5rem; color: var(--text); cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 0.5rem; font-size: 0.875rem;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09A1.65 1.65 0 0 0 8 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82-.33H9a2 2 0 1 1 0-4h.09c.31-.07.59-.2.83-.37.24-.17.45-.39.62-.62.17-.24.3-.52.37-.83H16a2 2 0 1 1 0 4h-.09c-.07.31-.2.59-.37.83-.17.24-.39.45-.62.62-.24.17-.52.3-.83.37V16a2 2 0 1 1-4 0v-.09c-.31-.07-.59-.2-.83-.37-.24-.17-.45-.39-.62-.62-.17-.24-.3-.52-.37-.83H8a2 2 0 1 1 0-4h.09c.07-.31.2-.59.37-.83.17-.24.39-.45.62-.62.24-.17.52-.3.83-.37V8a2 2 0 1 1 4 0v.09z"/>
                    </svg>
                    <span id="customizationSummary">Customize AI</span>
                </button>
            </div>
        </div>

        <div class="chat-container">
            <div class="chat-header">
                <div class="header-left">
                    <button class="toggle-sidebar-btn" id="toggleSidebarBtn" aria-label="Toggle sidebar" title="Toggle sidebar">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 12h18M3 6h18M3 18h18"/>
                        </svg>
                    </button>
                    <div class="chat-title" id="chatTitle">New Chat</div>
                </div>
                <button class="export-btn" id="exportBtn" aria-label="Export chat" title="Export chat">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7,10 12,15 17,10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                </button>
                <button class="settings-btn" id="settingsBtn" aria-label="Open settings" title="Settings">
                    <span style="font-size: 1.2rem;"></span>
                </button>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="message-wrapper">
                    <div class="message-bubble ai-message">
                        <div class="message-content">
                            <h1>Welcome! </h1>
                            
                            <p>I'm your AI assistant, ready to help you with any questions or tasks you might have. I can:</p>
                            
                            <h2>What I can do</h2>
                            <ul>
                                <li><strong>Answer questions</strong> and provide explanations</li>
                                <li><strong>Help with coding</strong> and technical problems</li>
                                <li><strong>Analyze documents</strong> and files you upload</li>
                                <li><strong>Generate creative content</strong> like stories, poems, or ideas</li>
                                <li><strong>Assist with writing</strong> and editing</li>
                            </ul>
                            
                            <div style="background: rgba(37, 99, 235, 0.1); border: 1px solid rgba(37, 99, 235, 0.2); border-radius: 8px; padding: 12px; margin: 16px 0;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 16px;"></span>
                                    <strong style="color: #2563eb;">Office File Support</strong>
                                </div>
                                <p style="margin: 0; font-size: 0.9em; color: var(--text);">
                                    Office files (DOC, DOCX, XLS, XLSX, PPT, PPTX) are automatically converted to text for better AI processing in Gemini.
                                </p>
                            </div>
                            
                            <h2>Getting started</h2>
                            <p>Simply type your message below and I'll respond with clear, well-formatted answers using <strong>rich text formatting</strong> for better readability.</p>
                            
                            <h3>Supported formatting:</h3>
                            <ul>
                                <li><strong>Bold text</strong> and <em>italic text</em></li>
                                <li><code>Inline code</code> and code blocks with syntax highlighting</li>
                                <li class="task-list-item"><input type="checkbox" disabled> Checklists and <input type="checkbox" checked disabled> completed tasks</li>
                                <li>Nested lists with proper indentation</li>
                                <li>Blockquotes with nesting support</li>
                                <li>Tables with column alignment</li>
                                <li>Horizontal rules for section separation</li>
                            </ul>
                            
                            <hr>
                            
                            <p>This horizontal rule above demonstrates the improved styling with better visibility across all themes.</p>
                            
                            <p><em>Feel free to ask me anything!</em></p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chat-input-area">
                <div id="imagePreviewContainer" class="image-preview-container" style="display: none;"></div>
                <div class="input-and-buttons">
                    <input type="file" id="fileInput" accept="image/*,audio/*,video/*,.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.csv,.md,.tex,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation,application/pdf,text/plain,text/csv,text/markdown,application/x-tex" multiple style="display: none;">
                    <button class="attach-file-btn" id="attachFileBtn" aria-label="Attach files (Office files auto-convert to text)" title="Attach files (Office files auto-convert to text)">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21.44 11.02L13 2.58a2 2 0 0 0-2.83 0l-8.86 8.86a2 2 0 0 0 0 2.83l8.86 8.86a2 2 0 0 0 2.83 0l8.44-8.44a2 2 0 0 0 0-2.83z"/>
                            <line x1="16" y1="8" x2="8" y2="16"/>
                        </svg>
                    </button>
                    <button class="generate-image-btn" id="generateImageBtn" aria-label="Generate image with AI" title="Generate image with AI" style="display: none;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/>
                            <circle cx="12" cy="13" r="3"/>
                        </svg>
                    </button>
                <div class="input-wrapper">
                    <textarea class="chat-input" id="chatInput" placeholder="Type your message..." rows="1" aria-label="Chat message input"></textarea>
                </div>
                <button class="send-btn" id="sendBtn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="apiKeyModal">
        <div class="settings-modal-content">
            <div class="settings-modal-header">
                <div class="settings-header-content">
                    <div class="settings-icon"></div>
                    <div class="settings-title">Settings</div>
                    <div class="settings-subtitle">Configure your AI experience</div>
                </div>
                <button class="modal-close" id="modalClose"></button>
            </div>
            
            <div class="settings-modal-body">
                <!-- Model Selection Section -->
                <div class="settings-section">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <div class="section-title">Model Selection</div>
                    </div>
                    <div class="section-content">
                        <div class="model-selector-wrapper">
                            <select id="modelSelector" class="modern-select">
                                <option value="gemini-2.5-flash">Gemini 2.5 Flash (Google) - Full file support</option>
                                <option value="gemini-2.0-flash-image">Gemini 2.0 Flash (Image Generation)</option>
                                <option value="grok-3-beta">Grok 3 Beta (xAI) - Text only, requires credits</option>
                            </select>
                            <div class="select-arrow"></div>
                        </div>
                        <div class="model-info">
                            <div class="info-item" id="geminiTokenNote">
                                <div class="info-icon"></div>
                                <div class="info-text">Gemini 2.5 Flash: Max input tokens: 1,048,576 (~4M chars), Max output tokens: 65,535 (~262,140 chars).</div>
                            </div>
                            <div class="info-item warning" id="grokCreditWarning" style="display:none;">
                                <div class="info-icon"></div>
                                <div class="info-text">Grok 3 requires OpenRouter credits. Free tier allows ~1400 tokens per response.</div>
                            </div>
                            <div class="info-item warning" id="imageGenerationNote" style="display:none;">
                                <div class="info-icon"></div>
                                <div class="info-text">Image generation: All images will have a SynthID watermark. Free tier only. Use camera icon to generate images.</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Timeout Section -->
                <div class="settings-section">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <div class="section-title">Response Timeout</div>
                    </div>
                    <div class="section-content">
                        <div class="timeout-control">
                            <div class="timeout-slider-wrapper">
                                <input type="range" id="timeoutSlider" min="15" max="120" value="60" class="modern-slider">
                                <div class="slider-track"></div>
                            </div>
                            <div class="timeout-value">
                                <span id="timeoutValue">60s</span>
                            </div>
                        </div>
                        <div class="timeout-hint">Set how long to wait for a response before cancelling (15120 seconds, default 60).</div>
                    </div>
                </div>

                <!-- API Keys Section -->
                <div class="settings-section">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <div class="section-title">API Configuration</div>
                    </div>
                    <div class="section-content">
                        <div id="apiKeySection">
                            <div id="geminiApiSection" class="api-key-wrapper">
                                <label class="api-key-label">Gemini API Key</label>
                                <div class="input-wrapper">
                                    <input type="password" class="modern-input" id="apiKeyInput" placeholder="Enter your Gemini API Key">
                                    <div class="input-icon"></div>
                                </div>
                            </div>
                            <div id="openrouterApiSection" class="api-key-wrapper" style="display:none;">
                                <label class="api-key-label">OpenRouter API Key</label>
                                <div class="input-wrapper">
                                    <input type="password" class="modern-input" id="openrouterApiKeyInput" placeholder="Enter your OpenRouter API Key">
                                    <div class="input-icon"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Theme Section -->
                <div class="settings-section">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <div class="section-title">Theme</div>
                    </div>
                    <div class="section-content">
                        <div class="theme-selector" id="themeSelector">
                            <button class="theme-option" data-theme="night">
                                <div class="theme-preview night-preview"></div>
                                <div class="theme-label">Night</div>
                            </button>
                            <button class="theme-option" data-theme="dim">
                                <div class="theme-preview dim-preview"></div>
                                <div class="theme-label">Dim</div>
                            </button>
                            <button class="theme-option" data-theme="light">
                                <div class="theme-preview light-preview"></div>
                                <div class="theme-label">Light</div>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- AI Customization Section -->
                <div class="settings-section">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <div class="section-title">AI Customization</div>
                    </div>
                    <div class="section-content">
                        <button class="customization-btn" id="openCustomizationBtn">
                            <div class="btn-content">
                                <div class="btn-icon"></div>
                                <div class="btn-text">
                                    <div class="btn-title">Customize AI Assistant</div>
                                    <div class="btn-subtitle">Personalize the AI's personality, communication style, and context</div>
                                </div>
                                <div class="btn-arrow"></div>
                            </div>
                        </button>
                    </div>
                </div>
            </div>

            <div class="settings-modal-footer">
                <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                    <button class="storage-info-btn" onclick="showStorageInfo()" style="
                        background: var(--card);
                        border: 1px solid var(--border);
                        color: var(--text-secondary);
                        padding: 0.5rem 1rem;
                        border-radius: 0.5rem;
                        font-size: 0.875rem;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    ">
                         Storage Info
                    </button>
                    <button class="save-settings-btn" id="saveApiKeyBtn">
                        <span class="btn-text">Save Settings</span>
                        <div class="btn-loading" style="display: none;">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Chat Delete Modal -->
    <div class="modal-overlay" id="chatDeleteModal">
        <div class="modal-content" style="max-width: 350px; text-align: center;">
            <button class="modal-close" id="chatDeleteModalClose"></button>
            <div class="modal-header" style="margin-bottom: 0.5rem;">Delete this chat?</div>
            <div style="color: #ef4444; margin-bottom: 1rem;">This cannot be undone.</div>
            <div class="chat-delete-confirm-btns">
                <button class="chat-delete-btn" id="chatDeleteConfirmBtn">Delete</button>
                <button class="chat-cancel-btn" id="chatDeleteCancelBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Export Chat Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal-content" style="max-width: 450px;">
            <button class="modal-close" id="exportModalClose"></button>
            <div class="modal-header">Export Chat</div>
            
            <div style="margin-bottom: 1.5rem;">
                <div style="font-weight: 600; margin-bottom: 0.75rem;">Export Format</div>
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <label class="export-format-option">
                        <input type="radio" name="exportFormat" value="pdf" checked>
                        <span>PDF</span>
                    </label>
                    <label class="export-format-option">
                        <input type="radio" name="exportFormat" value="docx">
                        <span>DOCX</span>
                    </label>
                    <label class="export-format-option">
                        <input type="radio" name="exportFormat" value="md">
                        <span>Markdown</span>
                    </label>
                </div>
            </div>
            
            <div style="margin-bottom: 1.5rem;">
                <label class="export-option-checkbox">
                    <input type="checkbox" id="includeUserMessages" checked>
                    <span>Include user messages</span>
                </label>
                <div style="font-size: 0.8rem; color: #9ca3af; margin-top: 0.5rem;">
                    When unchecked, only AI responses will be exported.
                </div>
            </div>
            
            <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
                <button class="chat-cancel-btn" id="exportCancelBtn">Cancel</button>
                <button class="save-btn" id="exportConfirmBtn">Export</button>
            </div>
        </div>
    </div>

    <!-- Code Block Popup Modal -->
    <div class="code-modal-overlay" id="codeModalOverlay">
        <div class="code-modal">
            <div class="code-modal-header">
                <span id="codeModalTitle">Code</span>
                <button class="code-modal-copy-btn" id="codeModalCopyBtn">Copy</button>
                <button class="code-modal-close" id="codeModalClose"></button>
            </div>
            <div class="code-modal-content">
                <pre><code id="codeModalContent" class="language-text"></code></pre>
            </div>
        </div>
    </div>

    <!-- AI Customization Modal -->
    <div class="modal-overlay" id="customizationModal">
        <div class="customization-modal-content">
            <div class="customization-modal-header">
                <div class="customization-header-content">
                    <div class="customization-icon"></div>
                    <div class="customization-title">Customize Your AI</div>
                    <div class="customization-subtitle">Personalize your AI assistant for better conversations</div>
                </div>
                <button class="modal-close" id="customizationModalClose"></button>
            </div>
            
            <div class="customization-modal-body">
                <!-- Personal Information Section -->
                <div class="customization-section">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <div class="section-title">Personal Information</div>
                    </div>
                    <div class="section-content">
                        <div class="input-group">
                            <label class="modern-label">
                                <div class="label-text">What should the AI call you?</div>
                                <div class="input-wrapper">
                                    <input type="text" id="userNameInput" class="modern-input" placeholder="Alex, Developer, or leave empty">
                                    <div class="input-icon"></div>
                                </div>
                                <div class="input-hint">This helps the AI personalize responses to you</div>
                            </label>
                        </div>
                        
                        <div class="input-group">
                            <label class="modern-label">
                                <div class="label-text">What do you do?</div>
                                <div class="input-wrapper">
                                    <input type="text" id="userProfessionInput" class="modern-input" placeholder="Software Developer, Student, Designer, etc.">
                                    <div class="input-icon"></div>
                                </div>
                                <div class="input-hint">This helps the AI understand your context</div>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- AI Personality Section -->
                <div class="customization-section">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <div class="section-title">AI Personality</div>
                    </div>
                    <div class="section-content">
                        <div class="personality-description">
                            Choose traits that match your preferred communication style. You can select multiple traits to create a unique personality.
                        </div>
                        <div class="traits-grid">
                            <label class="trait-option">
                                <input type="checkbox" value="chatty">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Chatty</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="witty">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Witty</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="straight-shooting">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Straight shooting</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="encouraging">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Encouraging</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="gen-z">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Gen Z</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="skeptical">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Skeptical</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="traditional">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Traditional</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="forward-thinking">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Forward thinking</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="poetic">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Poetic</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="technical">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Technical</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="casual">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Casual</div>
                                </div>
                            </label>
                            <label class="trait-option">
                                <input type="checkbox" value="formal">
                                <div class="trait-content">
                                    <div class="trait-icon"></div>
                                    <div class="trait-text">Formal</div>
                                </div>
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Additional Context Section -->
                <div class="customization-section">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <div class="section-title">Additional Context</div>
                    </div>
                    <div class="section-content">
                        <label class="modern-label">
                            <div class="label-text">Anything else the AI should know about you?</div>
                            <div class="textarea-wrapper">
                                <textarea id="userContextInput" class="modern-textarea" placeholder="e.g., I'm learning Python, I work in healthcare, I prefer detailed explanations..." rows="4"></textarea>
                                <div class="textarea-icon"></div>
                            </div>
                            <div class="input-hint">Additional context helps the AI provide more personalized responses</div>
                        </label>
                    </div>
                </div>
            </div>

            <div class="customization-modal-footer">
                <button class="cancel-customization-btn" id="customizationCancelBtn">Cancel</button>
                <button class="save-customization-btn" id="customizationSaveBtn">
                    <span class="btn-text">Save Changes</span>
                    <div class="btn-loading" style="display: none;">
                        <div class="loading-dot"></div>
                        <div class="loading-dot"></div>
                        <div class="loading-dot"></div>
                    </div>
                </button>
            </div>
        </div>
    </div>
    <!-- Image Generation Modal -->
    <div class="image-generation-modal" id="imageGenerationModal">
        <div class="image-generation-content">
            <div class="image-generation-header">
                <h3>Generate Image with AI</h3>
                <button class="close-image-modal" id="imageGenerationModalClose"></button>
            </div>
            
            <div class="image-generation-body">
                <div class="image-generation-left">
                    <div class="image-prompt-section">
                        <label for="imagePromptInput">Image Description</label>
                        <textarea id="imagePromptInput" class="image-prompt-input" placeholder="Describe the image you want to generate...&#10;&#10;Example: A serene mountain landscape at sunset with a crystal clear lake reflecting the sky" rows="6"></textarea>
                        <div style="font-size: 0.85rem; color: var(--sidebar-icon); margin-top: 0.5rem;">
                             Be specific and detailed for better results
                        </div>
                    </div>
                    
                    <div class="reference-image-section">
                        <label for="referenceImageInput">Reference Image (Optional)</label>
                        <div style="display: flex; gap: 0.75rem; align-items: center; margin-bottom: 0.5rem;">
                            <input type="file" id="referenceImageInput" accept="image/*" style="display: none;">
                            <button type="button" id="uploadReferenceBtn" class="upload-reference-btn">
                                 Upload Reference Image
                            </button>
                            <span id="referenceImageName" class="reference-image-name"></span>
                        </div>
                        <div id="referenceImagePreview" class="reference-image-preview">
                            <img id="referenceImage" alt="Reference image">
                            <div class="reference-image-info">
                                <span class="reference-image-name"></span>
                                <button type="button" id="removeReferenceBtn" class="remove-reference-btn">Remove</button>
                            </div>
                        </div>
                        <div style="font-size: 0.85rem; color: var(--sidebar-icon); margin-top: 0.5rem;">
                             Upload a reference image to guide the AI generation
                        </div>
                    </div>
                    
                    <div class="image-generation-actions">
                        <button class="cancel-image-btn" id="imageGenerationCancelBtn">Cancel</button>
                        <button class="generate-image-btn" id="generateImageConfirmBtn">Generate Image</button>
                    </div>
                </div>
                
                <div class="image-generation-right">
                    <div id="imageGenerationResult" class="image-generation-result">
                        <img id="generatedImage" class="generated-image" alt="Generated image">
                        <div class="image-result-actions">
                            <button class="download-image-btn" id="downloadImageBtn">Download Image</button>
                            <button class="regenerate-image-btn" id="regenerateImageBtn">Regenerate</button>
                        </div>
                    </div>
                    
                    <div class="image-loading" id="imageLoading" style="display: none;">
                        <div class="image-loading-spinner"></div>
                        <div>Generating your image...</div>
                    </div>
                    
                    <div class="image-placeholder" id="imagePlaceholder">
                        <div class="image-placeholder-icon"></div>
                        <div class="image-placeholder-text">Image Preview</div>
                        <div class="image-placeholder-subtext">Your generated image will appear here</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            MOBILE_BREAKPOINT: 768,
            MAX_OUTPUT_TOKENS: 65535, // Gemini 2.5 Flash max output tokens
            MAX_TOKENS: 1024,
            LONG_LINE_THRESHOLD: 100,
            SCROLL_DEBOUNCE: 100,
            COPY_FEEDBACK_DELAY: 1500,
            MODAL_DELAY: 1000,
            MAX_TIMEOUT: 300, // 5 minutes
            DEFAULT_TIMEOUT: 60
        };
        
        const MODELS = {
            'gemini-2.5-flash': {
                name: 'Gemini 2.5 Flash',
                provider: 'Google',
                endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent',
                format: 'gemini',
                supportsFiles: true
            },
            'gemini-2.0-flash-image': {
                name: 'Gemini 2.0 Flash (Image Generation)',
                provider: 'Google',
                endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent',
                format: 'gemini-image',
                supportsFiles: false,
                supportsImageGeneration: true
            },
            'grok-3-beta': {
                name: 'Grok 3 Beta',
                provider: 'xAI',
                endpoint: 'https://openrouter.ai/api/v1/chat/completions',
                format: 'openai',
                supportsFiles: false
            }
        };
        
        const STORAGE_KEYS = {
            API_KEY: 'gemini_api_key',
            OPENROUTER_API_KEY: 'openrouter_api_key',
            CHATS: 'gemini_chat_sessions',
            THEME: 'gemini_theme',
            SELECTED_MODEL: 'selected_model',
            CURRENT_CHAT: 'current_chat_id',
            SCROLL_POSITION: 'chat_scroll_position',
            RESPONSE_TIMEOUT: 'response_timeout_sec',
            CUSTOMIZATION: 'ai_customization'
        };

        // AI Customization data structure
        const AI_CUSTOMIZATION = {
            userName: '',
            userProfession: '',
            aiTraits: [],
            userContext: ''
        };

        // Global state
        let currentApiKey = "";
        let currentOpenRouterApiKey = "";
        let selectedModel = "gemini-2.5-flash";
        let allChats = [];
        let currentChatId = null;
        let chatHistory = [];
        let isSidebarOpen = true;
        let tempChatId = null; // Track current temporary chat
        let tempChatHistory = []; // Store temporary chat history in memory only
        let selectedFiles = [];
        let renamingChatId = null;
        let deleteConfirmChatId = null;
        let searchQuery = '';
        let editingMessageId = null;
        let isSavingEdit = false; // Prevent multiple save operations
        let responseTimeoutSec = CONFIG.DEFAULT_TIMEOUT; // Default 60s
        let aiCustomization = { ...AI_CUSTOMIZATION }; // AI customization settings

        // DOM elements
        const elements = {
            sidebar: document.getElementById('sidebar'),
            toggleSidebarBtn: document.getElementById('toggleSidebarBtn'),
            newChatBtn: document.getElementById('newChatBtn'),
            tempChatBtn: document.getElementById('tempChatBtn'),
            chatList: document.getElementById('chatList'),
            chatTitle: document.getElementById('chatTitle'),
            chatMessages: document.getElementById('chatMessages'),
            chatInput: document.getElementById('chatInput'),
            sendBtn: document.getElementById('sendBtn'),
            settingsBtn: document.getElementById('settingsBtn'),
            apiKeyModal: document.getElementById('apiKeyModal'),
            apiKeyInput: document.getElementById('apiKeyInput'),
            openrouterApiKeyInput: document.getElementById('openrouterApiKeyInput'),
            modelSelector: document.getElementById('modelSelector'),
            geminiApiSection: document.getElementById('geminiApiSection'),
            openrouterApiSection: document.getElementById('openrouterApiSection'),
            grokCreditWarning: document.getElementById('grokCreditWarning'),
            saveApiKeyBtn: document.getElementById('saveApiKeyBtn'),
            modalClose: document.getElementById('modalClose'),
            chatDeleteModal: document.getElementById('chatDeleteModal'),
            chatDeleteModalClose: document.getElementById('chatDeleteModalClose'),
            chatDeleteConfirmBtn: document.getElementById('chatDeleteConfirmBtn'),
            chatDeleteCancelBtn: document.getElementById('chatDeleteCancelBtn'),
            attachFileBtn: document.getElementById('attachFileBtn'),
            generateImageBtn: document.getElementById('generateImageBtn'),
            fileInput: document.getElementById('fileInput'),
            imagePreviewContainer: document.getElementById('imagePreviewContainer'),
            chatSearchInput: document.getElementById('chatSearchInput'),
            clearSearchBtn: document.getElementById('clearSearchBtn'),
            importBtn: document.getElementById('importBtn'),
            exportBtn: document.getElementById('exportBtn'),
            exportModal: document.getElementById('exportModal'),
            exportModalClose: document.getElementById('exportModalClose'),
            exportCancelBtn: document.getElementById('exportCancelBtn'),
            exportConfirmBtn: document.getElementById('exportConfirmBtn'),
            includeUserMessages: document.getElementById('includeUserMessages'),
            imageGenerationModal: document.getElementById('imageGenerationModal'),
            imageGenerationModalClose: document.getElementById('imageGenerationModalClose'),
            imagePromptInput: document.getElementById('imagePromptInput'),
            imageGenerationResult: document.getElementById('imageGenerationResult'),
            generatedImage: document.getElementById('generatedImage'),
            downloadImageBtn: document.getElementById('downloadImageBtn'),
            regenerateImageBtn: document.getElementById('regenerateImageBtn'),
            imageGenerationCancelBtn: document.getElementById('imageGenerationCancelBtn'),
            generateImageConfirmBtn: document.getElementById('generateImageConfirmBtn'),
            referenceImageInput: document.getElementById('referenceImageInput'),
            uploadReferenceBtn: document.getElementById('uploadReferenceBtn'),
            referenceImageName: document.getElementById('referenceImageName'),
            referenceImagePreview: document.getElementById('referenceImagePreview'),
            referenceImage: document.getElementById('referenceImage'),
            removeReferenceBtn: document.getElementById('removeReferenceBtn'),
            customizationModal: document.getElementById('customizationModal'),
            customizationModalClose: document.getElementById('customizationModalClose'),
            customizationCancelBtn: document.getElementById('customizationCancelBtn'),
            customizationSaveBtn: document.getElementById('customizationSaveBtn'),
            codeModalOverlay: document.getElementById('codeModalOverlay'),
            codeModalClose: document.getElementById('codeModalClose'),
            codeModalCopyBtn: document.getElementById('codeModalCopyBtn'),
            codeModalTitle: document.getElementById('codeModalTitle'),
            codeModalContent: document.getElementById('codeModalContent')
        };



        // Utility functions
        function generateId() {
            return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function generateTitle(message) {
            const clean = message.replace(/\s+/g, ' ').trim();
            return clean.length > 30 ? clean.substring(0, 30) + '...' : clean || 'New Chat';
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).catch(err => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
            });
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // New: File to Base64 converter
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]); // Get base64 string without data:mime/type;
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        // Enhanced Image preview handling with proper memory management
        function renderImagePreviews() {
            // Clear existing previews and revoke object URLs
            clearImagePreviews();
            
            if (selectedFiles.length === 0) {
                elements.imagePreviewContainer.style.display = 'none';
                return;
            }
            elements.imagePreviewContainer.style.display = 'flex';

            selectedFiles.forEach((file, index) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'image-preview-item';

                let previewContent;
                if (file.type.startsWith('image/')) {
                    previewContent = document.createElement('img');
                    const objectUrl = URL.createObjectURL(file);
                    previewContent.src = objectUrl;
                    previewContent.alt = file.name;
                    // Store object URL for cleanup
                    previewContent.dataset.objectUrl = objectUrl;
                    previewContent.onload = () => {
                        // URL is already created, no need to revoke here
                        // Will be revoked when preview is removed
                    };
                } else if (file.type.startsWith('audio/')) {
                    previewContent = document.createElement('audio');
                    previewContent.controls = true;
                    const objectUrl = URL.createObjectURL(file);
                    previewContent.src = objectUrl;
                    previewContent.dataset.objectUrl = objectUrl;
                    previewContent.onloadeddata = () => {
                        // URL is already created, no need to revoke here
                        // Will be revoked when preview is removed
                    };
                } else if (file.type.startsWith('video/')) {
                    previewContent = document.createElement('video');
                    previewContent.controls = true;
                    const objectUrl = URL.createObjectURL(file);
                    previewContent.src = objectUrl;
                    previewContent.dataset.objectUrl = objectUrl;
                    previewContent.onloadeddata = () => {
                        // URL is already created, no need to revoke here
                        // Will be revoked when preview is removed
                    };
                } else {
                    // Document or other file
                    previewContent = document.createElement('div');
                    previewContent.style.display = 'flex';
                    previewContent.style.flexDirection = 'column';
                    previewContent.style.alignItems = 'center';
                    // Icon
                    const icon = document.createElement('span');
                    icon.className = 'file-preview-icon';
                    icon.innerHTML = getFileIconSVG({
                        name: file.name,
                        type: file.type
                    });
                    // Info
                    const info = document.createElement('div');
                    info.className = 'file-preview-info';
                    info.textContent = `${file.name} (${formatFileSize(file.size)})`;
                    previewContent.appendChild(icon);
                    previewContent.appendChild(info);
                }

                const removeBtn = document.createElement('button');
                removeBtn.className = 'image-preview-remove';
                removeBtn.innerHTML = '&times;';
                removeBtn.addEventListener('click', () => removeImagePreview(index));

                previewItem.appendChild(previewContent);
                previewItem.appendChild(removeBtn);
                elements.imagePreviewContainer.appendChild(previewItem);
            });
        }

        // Clear image previews and revoke object URLs
        function clearImagePreviews() {
            const previews = elements.imagePreviewContainer.querySelectorAll('img, audio, video');
            previews.forEach(preview => {
                if (preview.dataset.objectUrl) {
                    URL.revokeObjectURL(preview.dataset.objectUrl);
                }
            });
            elements.imagePreviewContainer.innerHTML = '';
        }

        // Helper: Get SVG icon for file type
        function getFileIconSVG(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (file.type === 'application/pdf' || ext === 'pdf') {
                return `<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M7 7h10M7 11h10M7 15h6"/></svg>`;
            } else if (["doc","docx"].includes(ext)) {
                return `<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M7 7h10M7 11h10M7 15h6"/><text x="6" y="20" font-size="8">DOC</text></svg>`;
            } else if (["xls","xlsx","csv"].includes(ext)) {
                return `<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M7 7h10M7 11h10M7 15h6"/><text x="6" y="20" font-size="8">XLS</text></svg>`;
            } else if (["ppt","pptx"].includes(ext)) {
                return `<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M7 7h10M7 11h10M7 15h6"/><text x="6" y="20" font-size="8">PPT</text></svg>`;
            } else if (["md","txt","tex"].includes(ext)) {
                return `<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M7 7h10M7 11h10M7 15h6"/><text x="6" y="20" font-size="8">TXT</text></svg>`;
            } else {
                return `<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M7 7h10M7 11h10M7 15h6"/></svg>`;
            }
        }

        // Helper: Format file size
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Image Generation Functions
        function openImageGenerationModal() {
            // Check if image generation model is selected
            const model = MODELS[selectedModel];
            if (!model.supportsImageGeneration) {
                alert('Please select "Gemini 2.0 Flash (Image Generation)" model to generate images.');
                openModal();
                return;
            }
            
            // Check for API key
            if (!currentApiKey) {
                alert('Please set your Gemini API key in settings');
                openModal();
                return;
            }
            
            elements.imageGenerationModal.classList.add('visible');
            elements.imagePromptInput.focus();
            elements.imageGenerationResult.classList.remove('visible');
            elements.imagePromptInput.value = '';
            
            // Show placeholder and hide loading
            document.getElementById('imagePlaceholder').style.display = 'flex';
            document.getElementById('imageLoading').style.display = 'none';
            
            // Clear any previous reference image
            elements.referenceImage.src = '';
            elements.referenceImageName.textContent = '';
            elements.referenceImagePreview.classList.remove('visible');
            elements.referenceImageInput.value = '';
            console.log('[openImageGenerationModal] Reference image cleared');
        }

        function closeImageGenerationModal() {
            elements.imageGenerationModal.classList.remove('visible');
            // Reset to placeholder state
            document.getElementById('imagePlaceholder').style.display = 'flex';
            document.getElementById('imageLoading').style.display = 'none';
            elements.imageGenerationResult.classList.remove('visible');
        }

        async function generateImage(prompt) {
            if (!prompt.trim()) {
                alert('Please enter a description for the image you want to generate.');
                return;
            }

            const model = MODELS[selectedModel];
            if (!model.supportsImageGeneration) {
                alert('Image generation is only available with Gemini 2.0 Flash (Image Generation) model.');
                return;
            }

            // Show loading state
            elements.generateImageConfirmBtn.disabled = true;
            elements.generateImageConfirmBtn.textContent = 'Generating...';
            
            // Show loading in right panel
            document.getElementById('imagePlaceholder').style.display = 'none';
            document.getElementById('imageLoading').style.display = 'flex';

            try {
                const url = `${model.endpoint}?key=${currentApiKey}`;
                
                // Prepare parts array
                const parts = [{ text: prompt }];
                
                // Add reference image if uploaded
                const referenceImage = elements.referenceImage;
                if (!referenceImage) {
                    console.log('[generateImage] Reference image element not found');
                } else {
                    console.log('[generateImage] Reference image src:', referenceImage.src);
                    if (referenceImage.src && referenceImage.src !== '' && !referenceImage.src.includes('data:,')) {
                        const referenceImageData = referenceImage.src.split(',')[1]; // Get base64 data
                        if (referenceImageData) {
                            console.log('[generateImage] Adding reference image to request');
                            parts.push({
                                inlineData: {
                                    mimeType: 'image/jpeg',
                                    data: referenceImageData
                                }
                            });
                        }
                    } else {
                        console.log('[generateImage] No reference image to add');
                    }
                }
                
                const requestBody = {
                    contents: [{
                        parts: parts
                    }],
                    generationConfig: {
                        responseModalities: ["IMAGE", "TEXT"]
                    }
                };

                console.log('[generateImage] Sending request:', requestBody);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('[generateImage] Response status:', response.status);
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('[generateImage] API error:', errorData);
                    throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('[generateImage] Response data:', data);

                // Find the base64 image in the response
                let imgData = null;
                let textResponse = null;
                if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
                    for (const part of data.candidates[0].content.parts) {
                        if (part.inlineData && part.inlineData.data) {
                            imgData = part.inlineData.data;
                        } else if (part.text) {
                            textResponse = part.text;
                        }
                    }
                }

                if (imgData) {
                    // Display the generated image
                    elements.generatedImage.src = `data:image/png;base64,${imgData}`;
                    elements.imageGenerationResult.classList.add('visible');
                    
                    // Hide loading and placeholder
                    document.getElementById('imageLoading').style.display = 'none';
                    document.getElementById('imagePlaceholder').style.display = 'none';
                    
                    // Store the image data for download
                    elements.generatedImage.dataset.imageData = imgData;
                    
                    // Add to chat history with image data
                    const userMessageId = generateId();
                    const aiMessageId = generateId();
                    
                    // Add user message
                    addMessage(`Generated image: "${prompt}"`, 'user', null, null, userMessageId);
                    
                    // Add AI message with image
                    const aiMessage = textResponse ? `Here's your generated image: ${textResponse}` : `Here's your generated image:`;
                    addMessage(aiMessage, 'ai', null, selectedModel, aiMessageId, `data:image/png;base64,${imgData}`);
                    
                    // Save to localStorage
                    if (tempChatId && currentChatId === null) {
                        // Temporary chat - store in memory only
                        tempChatHistory.push({ 
                            id: userMessageId, 
                            role: "user", 
                            parts: [{ text: `Generated image: "${prompt}"` }],
                            type: "text"
                        });
                        tempChatHistory.push({ 
                            id: aiMessageId, 
                            role: "model", 
                            parts: [{ text: aiMessage }], 
                            modelUsed: selectedModel,
                            type: "image",
                            imageData: `data:image/png;base64,${imgData}`
                        });
                        chatHistory.push({ 
                            id: userMessageId, 
                            role: "user", 
                            parts: [{ text: `Generated image: "${prompt}"` }],
                            type: "text"
                        });
                        chatHistory.push({ 
                            id: aiMessageId, 
                            role: "model", 
                            parts: [{ text: aiMessage }], 
                            modelUsed: selectedModel,
                            type: "image",
                            imageData: `data:image/png;base64,${imgData}`
                        });
                    } else {
                        // Regular chat - save to localStorage
                        updateCurrentChat({ 
                            id: userMessageId, 
                            role: "user", 
                            parts: [{ text: `Generated image: "${prompt}"` }],
                            type: "text"
                        });
                        updateCurrentChat({ 
                            id: aiMessageId, 
                            role: "model", 
                            parts: [{ text: aiMessage }], 
                            modelUsed: selectedModel,
                            type: "image",
                            imageData: `data:image/png;base64,${imgData}`
                        });
                    }
                    
                } else {
                    throw new Error('No image data received from API');
                }

            } catch (error) {
                console.error('[generateImage] Error:', error);
                alert(`Error generating image: ${error.message}`);
            } finally {
                // Reset button state
                elements.generateImageConfirmBtn.disabled = false;
                elements.generateImageConfirmBtn.textContent = 'Generate Image';
            }
        }

        function downloadGeneratedImage() {
            const imgData = elements.generatedImage.dataset.imageData;
            if (!imgData) {
                alert('No image to download');
                return;
            }

            // Create a download link
            const link = document.createElement('a');
            link.href = `data:image/png;base64,${imgData}`;
            link.download = `generated-image-${Date.now()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function handleFileSelect(event) {
            selectedFiles = []; // Clear previous selections
            if (event.target.files && event.target.files.length > 0) {
                await addFilesToSelection(event.target.files);
            }
            // Clear file input properly to allow re-selection of same file
            event.target.value = '';
        }

        // API Key and Model management
        function loadApiKey() {
            const stored = localStorage.getItem(STORAGE_KEYS.API_KEY);
            const openrouterStored = localStorage.getItem(STORAGE_KEYS.OPENROUTER_API_KEY);
            const modelStored = localStorage.getItem(STORAGE_KEYS.SELECTED_MODEL);
            const timeoutStored = localStorage.getItem(STORAGE_KEYS.RESPONSE_TIMEOUT);
            if (stored) {
                currentApiKey = stored;
            }
            if (openrouterStored) {
                currentOpenRouterApiKey = openrouterStored;
            }
            if (modelStored && MODELS[modelStored]) {
                selectedModel = modelStored;
            }
            if (timeoutStored && !isNaN(timeoutStored)) {
                responseTimeoutSec = Math.max(15, Math.min(120, parseInt(timeoutStored)));
            }
            return stored || openrouterStored;
        }

        async function saveApiKey() {
            const saveBtn = elements.saveApiKeyBtn;
            const btnText = saveBtn.querySelector('.btn-text');
            const btnLoading = saveBtn.querySelector('.btn-loading');
            
            // Show loading state
            saveBtn.classList.add('loading');
            btnText.style.display = 'none';
            btnLoading.style.display = 'flex';
            
            try {
                const model = elements.modelSelector.value;
                let isValid = true;
                
                if (model === 'gemini-2.5-flash' || model === 'gemini-2.0-flash-image') {
                    const key = elements.apiKeyInput.value.trim();
                    if (!key) {
                        alert('Please enter a valid Gemini API key');
                        isValid = false;
                    } else {
                        localStorage.setItem(STORAGE_KEYS.API_KEY, key);
                        currentApiKey = key;
                    }
                } else if (model === 'grok-3-beta') {
                    const key = elements.openrouterApiKeyInput.value.trim();
                    if (!key) {
                        alert('Please enter a valid OpenRouter API key');
                        isValid = false;
                    } else {
                        localStorage.setItem(STORAGE_KEYS.OPENROUTER_API_KEY, key);
                        currentOpenRouterApiKey = key;
                    }
                }
                
                // Save timeout
                const timeoutVal = parseInt(document.getElementById('timeoutSlider').value);
                responseTimeoutSec = Math.max(15, Math.min(CONFIG.MAX_TIMEOUT, timeoutVal));
                localStorage.setItem(STORAGE_KEYS.RESPONSE_TIMEOUT, responseTimeoutSec);
                
                if (isValid) {
                    localStorage.setItem(STORAGE_KEYS.SELECTED_MODEL, model);
                    selectedModel = model;
                    
                    // Simulate a brief delay for better UX
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    closeModal();
                    addMessage(`Settings saved successfully! Using ${MODELS[model].name}. Timeout: ${responseTimeoutSec}s.`, 'ai');
                }
            } catch (error) {
                console.error('Error saving settings:', error);
                alert('An error occurred while saving settings. Please try again.');
            } finally {
                // Hide loading state
                saveBtn.classList.remove('loading');
                btnText.style.display = 'block';
                btnLoading.style.display = 'none';
            }
        }

        function openModal() {
            elements.modelSelector.value = selectedModel;
            elements.apiKeyInput.value = currentApiKey;
            elements.openrouterApiKeyInput.value = currentOpenRouterApiKey;
            // Show/hide appropriate API key sections
            updateApiKeySection();
            // Set timeout slider
            const timeoutSlider = document.getElementById('timeoutSlider');
            const timeoutValue = document.getElementById('timeoutValue');
            timeoutSlider.max = CONFIG.MAX_TIMEOUT;
            timeoutSlider.value = responseTimeoutSec;
            timeoutValue.textContent = responseTimeoutSec + 's';
            timeoutSlider.oninput = function() {
                timeoutValue.textContent = this.value + 's';
            };
            elements.apiKeyModal.classList.add('visible');
            elements.apiKeyInput.focus();
        }
        
        function updateApiKeySection() {
            const model = elements.modelSelector.value;
            if (model === 'gemini-2.5-flash') {
                elements.geminiApiSection.style.display = 'block';
                elements.openrouterApiSection.style.display = 'none';
                elements.grokCreditWarning.style.display = 'none';
                document.getElementById('imageGenerationNote').style.display = 'none';
            } else if (model === 'gemini-2.0-flash-image') {
                elements.geminiApiSection.style.display = 'block';
                elements.openrouterApiSection.style.display = 'none';
                elements.grokCreditWarning.style.display = 'none';
                document.getElementById('imageGenerationNote').style.display = 'block';
            } else if (model === 'grok-3-beta') {
                elements.geminiApiSection.style.display = 'none';
                elements.openrouterApiSection.style.display = 'block';
                elements.grokCreditWarning.style.display = 'block';
                document.getElementById('imageGenerationNote').style.display = 'none';
            }
        }

        function updateImageGenerationButton() {
            const model = MODELS[elements.modelSelector.value];
            if (model && model.supportsImageGeneration) {
                elements.generateImageBtn.style.display = 'flex';
                // Hide text input and show image generation instructions
                elements.chatInput.style.display = 'none';
                elements.sendBtn.style.display = 'none';
                elements.attachFileBtn.style.display = 'none';
                
                // Show image generation instructions
                const instructionsDiv = document.getElementById('imageGenerationInstructions') || createImageGenerationInstructions();
                instructionsDiv.style.display = 'block';
                
                // Update placeholder text to indicate image mode
                elements.chatInput.placeholder = 'Image generation mode - use camera icon above';
            } else {
                elements.generateImageBtn.style.display = 'none';
                // Show text input and send button
                elements.chatInput.style.display = 'block';
                elements.sendBtn.style.display = 'flex';
                elements.attachFileBtn.style.display = 'flex';
                
                // Hide image generation instructions
                const instructionsDiv = document.getElementById('imageGenerationInstructions');
                if (instructionsDiv) {
                    instructionsDiv.style.display = 'none';
                }
                
                // Restore normal placeholder
                elements.chatInput.placeholder = 'Type your message...';
            }
        }

        function createImageGenerationInstructions() {
            const instructionsDiv = document.createElement('div');
            instructionsDiv.id = 'imageGenerationInstructions';
            instructionsDiv.style.cssText = `
                text-align: center;
                padding: 2rem;
                color: var(--text);
                background: var(--card);
                border: 1px solid var(--border);
                border-radius: 0.75rem;
                margin: 1rem 0;
            `;
            instructionsDiv.innerHTML = `
                <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem;">
                     Image Generation Mode
                </div>
                <div style="margin-bottom: 1rem; color: var(--sidebar-icon);">
                    You're currently using the image generation model. Click the camera icon above to generate images with AI.
                </div>
                <div style="font-size: 0.9rem; color: var(--sidebar-icon);">
                     Tip: Switch to "Gemini 2.5 Flash" in settings for text chat
                </div>
            `;
            
            // Insert after the input area
            const inputArea = document.querySelector('.chat-input-area');
            inputArea.appendChild(instructionsDiv);
            return instructionsDiv;
        }

        function closeModal() {
            elements.apiKeyModal.classList.remove('visible');
        }
        function closeCustomizationModal() {
            elements.customizationModal.classList.remove('visible');
        }

        function closeImageGenerationModal() {
            elements.imageGenerationModal.classList.remove('visible');
        }

        function closeExportModal() {
            elements.exportModal.classList.remove('visible');
        }

        function closeCodeModal() {
            elements.codeModalOverlay.classList.remove('visible');
        }

        // Export functionality
        function openExportModal() {
            elements.exportModal.classList.add('visible');
        }

        function closeExportModal() {
            elements.exportModal.classList.remove('visible');
        }

        function exportChatToFormat() {
            const format = document.querySelector('input[name="exportFormat"]:checked').value;
            const includeUser = elements.includeUserMessages.checked;
            
            // Get current chat messages
            const messages = chatHistory.filter(msg => {
                if (includeUser) return true;
                return msg.role === 'model';
            });

            if (messages.length === 0) {
                alert('No messages to export.');
                return;
            }

            const timestamp = new Date().toISOString().slice(0, 10);
            const filename = `chat-${timestamp}`;

            switch (format) {
                case 'pdf':
                    exportToPDF(messages, filename);
                    break;
                case 'docx':
                    exportToDOCX(messages, filename);
                    break;
                case 'md':
                    exportToMarkdown(messages, filename);
                    break;
            }
            
            closeExportModal();
        }

        // Advanced markdown processing for PDF export
        function processMarkdownForPDF(markdown) {
            const renderer = new marked.Renderer();
            
            // Custom rendering for code blocks with syntax highlighting
            renderer.code = (code, language) => {
                let highlightedCode = code;
                if (Prism && language) {
                    try {
                        highlightedCode = Prism.highlight(code, Prism.languages[language], language);
                    } catch (e) {
                        console.warn('Syntax highlighting failed:', e);
                    }
                }
                return `<div class="code-block">
                            <div class="code-header">
                                <div class="code-language">${language || 'text'}</div>
                            </div>
                            <div class="code-content">
                                <pre><code class="language-${language || 'text'}">${highlightedCode}</code></pre>
                            </div>
                        </div>`;
            };

            // Enhanced list rendering
            renderer.list = (body, ordered) => {
                const type = ordered ? 'ol' : 'ul';
                return `<${type} class="md-list ${ordered ? 'ordered' : 'unordered'}">${body}</${type}>`;
            };

            // Enhanced table rendering
            renderer.table = (header, body) => {
                return `<div class="table-container">
                            <table>
                                <thead>${header}</thead>
                                <tbody>${body}</tbody>
                            </table>
                        </div>`;
            };

            // Set up marked options
            marked.setOptions({
                renderer: renderer,
                highlight: function(code, language) {
                    if (Prism && language) {
                        try {
                            return Prism.highlight(code, Prism.languages[language], language);
                        } catch (e) {
                            console.warn('Syntax highlighting failed:', e);
                        }
                    }
                    return code;
                },
                pedantic: false,
                gfm: true,
                breaks: true,
                sanitize: false,
                smartypants: true,
                xhtml: true
            });

            return marked.parse(markdown);
        }

        // Show loading indicator
        function showLoadingIndicator() {
            const loader = document.createElement('div');
            loader.className = 'pdf-loading-indicator';
            loader.innerHTML = `
                <div class="loading-spinner"></div>
                <div class="loading-text">Generating PDF...</div>
            `;
            document.body.appendChild(loader);
            return loader;
        }

        // Add loading indicator styles
        const styleSheet = document.createElement('style');
        styleSheet.textContent = `
            .pdf-loading-indicator {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--modal-bg);
                padding: 2rem;
                border-radius: 1rem;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 1rem;
                z-index: 9999;
            }
            .loading-spinner {
                width: 40px;
                height: 40px;
                border: 3px solid var(--border);
                border-top-color: var(--accent);
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }
            .loading-text {
                color: var(--text);
                font-size: 1rem;
                font-weight: 500;
            }
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
            /* Enhanced PDF Styles */
            .md-list {
                padding-left: 2rem;
                margin: 1rem 0;
            }
            .md-list.ordered {
                list-style-type: decimal;
            }
            .md-list.unordered {
                list-style-type: disc;
            }
            .md-list li {
                margin: 0.5rem 0;
            }
        `;
        document.head.appendChild(styleSheet);

        // Update the exportToPDF function
        function exportToPDF(messages, filename) {
            const loader = showLoadingIndicator();
            
            try {
                const valid = messages.filter(m => m && m.parts && m.parts[0] && m.parts[0].text);
                if (valid.length === 0) {
                    throw new Error('No valid messages to export');
                }

                // Create a temporary container
                const container = document.createElement('div');
                container.style.width = '793px'; // A4 width
                container.style.margin = '0 auto';
                container.style.background = '#ffffff';
                document.body.appendChild(container);

                // Generate and inject content
                const content = createExportHTML(valid, true);
                container.innerHTML = content;

                // Process code blocks
                container.querySelectorAll('pre code').forEach(block => {
                    hljs.highlightElement(block);
                });

                // Wait for assets and then generate PDF
                Promise.all([
                    document.fonts.ready,
                    ...Array.from(container.getElementsByTagName('img'))
                        .map(img => img.complete ? Promise.resolve() : new Promise(resolve => {
                            img.onload = resolve;
                            img.onerror = resolve;
                        })),
                    new Promise(resolve => setTimeout(resolve, 1000))
                ]).then(() => {
                    // Configure PDF options
                    const opt = {
                        margin: [40, 40, 40, 40], // top, right, bottom, left margins in mm
                        filename: `${filename}.pdf`,
                        image: { type: 'jpeg', quality: 0.98 },
                        html2canvas: {
                            scale: 2,
                            useCORS: true,
                            letterRendering: true,
                            width: container.offsetWidth,
                            height: container.offsetHeight,
                            backgroundColor: '#ffffff'
                        },
                        jsPDF: {
                            unit: 'mm',
                            format: 'a4',
                            orientation: 'portrait',
                            compress: true
                        },
                        pagebreak: { 
                            mode: ['avoid-all', 'css', 'legacy'],
                            before: '.page-break',
                            avoid: ['tr', 'pre', 'blockquote', '.message']
                        }
                    };

                    // Generate PDF
                    html2pdf()
                        .from(container)
                        .set(opt)
                        .toPdf()
                        .get('pdf')
                        .then((pdf) => {
                            // Get total pages
                            const totalPages = pdf.internal.getNumberOfPages();
                            console.log(`Generated PDF with ${totalPages} pages`);
                            
                            // Add page numbers
                            for (let i = 1; i <= totalPages; i++) {
                                pdf.setPage(i);
                                pdf.setFontSize(10);
                                pdf.setTextColor(128, 128, 128);
                                pdf.text(
                                    `Page ${i} of ${totalPages}`,
                                    pdf.internal.pageSize.getWidth() / 2,
                                    pdf.internal.pageSize.getHeight() - 10,
                                    { align: 'center' }
                                );
                            }
                        })
                        .save()
                        .then(() => {
                            console.log('PDF export completed successfully');
                            document.body.removeChild(container);
                            if (loader) loader.parentNode.removeChild(loader);
                        })
                        .catch(error => {
                            console.error('PDF generation failed:', error);
                            alert('Failed to generate PDF: ' + error.message);
                            document.body.removeChild(container);
                            if (loader) loader.parentNode.removeChild(loader);
                        });
                }).catch(error => {
                    console.error('Asset loading failed:', error);
                    alert('Failed to load assets: ' + error.message);
                    document.body.removeChild(container);
                    if (loader) loader.parentNode.removeChild(loader);
                });

            } catch (error) {
                console.error('PDF export failed:', error);
                alert('Failed to export PDF: ' + error.message);
                if (loader) loader.parentNode.removeChild(loader);
            }
        }

        // Update createExportHTML to use enhanced markdown processing
        function createExportHTML(messages, useEnhancedMarkdown = false) {
    const style = `<style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        /* Reset and base styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #1f2937;
            background: #ffffff;
            font-size: 14px;
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }
        
        #pdf-wrapper {
            padding: 30px;
            max-width: 793px; /* A4 width */
            margin: 0 auto;
            background: #ffffff;
        }
        
        .chat-content {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }
        
        /* Message styles */
        .message {
            break-inside: avoid;
            page-break-inside: avoid;
            margin-bottom: 24px;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .user-message {
            background: #2563eb;
            color: #ffffff;
            margin-left: 80px;
            margin-right: 20px;
        }
        
        .ai-message {
            background: #f8fafc;
            color: #1f2937;
            border: 1px solid #e5e7eb;
            margin-right: 80px;
            margin-left: 20px;
        }

        .user-message code {
            background: rgba(255, 255, 255, 0.2) !important;
            color: #ffffff !important;
        }
        
        /* Typography */
        h1, h2, h3, h4, h5, h6 {
            color: #111827;
            font-weight: 600;
            line-height: 1.3;
            margin-top: 1.5em;
            margin-bottom: 0.75em;
        }
        
        h1 { 
            font-size: 24px; 
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.5em;
        }
        h2 { 
            font-size: 20px; 
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.3em;
        }
        h3 { font-size: 18px; }
        h4, h5, h6 { font-size: 16px; }
        
        .ai-message h1, .ai-message h2, .ai-message h3, 
        .ai-message h4, .ai-message h5, .ai-message h6 {
            color: #111827;
        }

        .user-message h1, .user-message h2, .user-message h3,
        .user-message h4, .user-message h5, .user-message h6 {
            color: #ffffff;
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        p {
            margin: 0 0 12px;
            line-height: 1.6;
        }

        strong, b {
            font-weight: 600;
        }

        .user-message strong, .user-message b {
            color: #ffffff;
        }

        .ai-message strong, .ai-message b {
            color: #111827;
        }
        
        /* Code blocks */
        pre {
            background: #1f2937 !important;
            color: #f9fafc !important;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 16px 0;
            font-size: 13px;
            line-height: 1.45;
            page-break-inside: avoid;
        }
        
        code {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            background: #f3f4f6;
            color: #dc2626;
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        pre code {
            background: transparent !important;
            color: #f9fafc !important;
            padding: 0;
        }
        
        /* Lists */
        ul, ol {
            margin: 12px 0 12px 24px;
            padding-left: 0;
        }
        
        li {
            margin: 6px 0;
        }

        .user-message ul, .user-message ol {
            color: #ffffff;
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid #2563eb;
            margin: 16px 0;
            padding: 12px 20px;
            background: #f8fafc;
            color: #4b5563;
            page-break-inside: avoid;
            font-style: italic;
        }

        .user-message blockquote {
            border-left-color: #ffffff;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        /* Tables */
        .table-container {
            margin: 16px 0;
            overflow-x: auto;
            page-break-inside: avoid;
            background: #ffffff;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            margin: 0;
        }
        
        th, td {
            border: 1px solid #e5e7eb;
            padding: 12px;
            text-align: left;
            color: #1f2937;
            background: #ffffff;
        }
        
        th {
            background: #f8fafc !important;
            font-weight: 600;
            color: #111827;
        }
        
        tr:nth-child(even) td {
            background: #f9fafb;
        }

        .user-message .table-container {
            background: #ffffff;
        }

        .user-message table th,
        .user-message table td {
            color: #1f2937;
        }
        
        /* Images */
        img {
            max-width: 100%;
            height: auto;
            margin: 16px 0;
            border-radius: 6px;
            page-break-inside: avoid;
        }
        
        /* Links */
        a {
            color: #2563eb;
            text-decoration: none;
        }

        .user-message a {
            color: #ffffff;
            text-decoration: underline;
        }
        
        /* Print-specific styles */
        @media print {
            body {
                background: #ffffff !important;
            }
            
            pre, code, blockquote, table {
                page-break-inside: avoid;
            }
            
            h1, h2, h3, h4, h5, h6 {
                page-break-after: avoid;
                color: #111827 !important;
            }
            
            img {
                page-break-inside: avoid;
            }

            .message {
                border: 1px solid #e5e7eb;
            }

            .user-message {
                background-color: #2563eb !important;
                color: #ffffff !important;
            }

            .ai-message {
                background-color: #f8fafc !important;
                color: #1f2937 !important;
            }
        }
    </style>`;

    const parts = messages.map(msg => {
        const text = msg.parts[0].text || '';
        const html = useEnhancedMarkdown ? processMarkdownForPDF(text) : 
                    (window.marked ? marked.parse(text) : text.replace(/\n/g, '<br>'));
        const cls = msg.role === 'user' ? 'user-message' : 'ai-message';
        return `<div class="message ${cls}"><div class="message-content">${html}</div></div>`;
    }).join('');
    return `<!DOCTYPE html>
            <html>
            <head>
                <meta charset='utf-8'>
                <title>Chat Export</title>
                ${style}
            </head>
            <body>
                <div id="pdf-wrapper">
                    <h1 style="text-align: center; margin-bottom: 32px; border-bottom: none;">Chat Conversation</h1>
                    <div class="chat-content">
                        ${parts}
                    </div>
                </div>
            </body>
            </html>`;
        }

        function exportToDOCX(messages, filename) {
            try {
                const valid = messages.filter(m=>m && m.parts && m.parts[0] && m.parts[0].text);
                if(valid.length===0) throw new Error('No valid messages');
                if(!window.htmlDocx){
                    alert('DOCX library not loaded.');
                    return;
                }
                const html = createExportHTML(valid);
                const blob = window.htmlDocx.asBlob(html);
                const url = URL.createObjectURL(blob);
                const a=document.createElement('a');
                a.href=url;
                a.download=`${filename}.docx`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }catch(err){
                console.error('DOCX export error', err);
                alert('Failed to export DOCX: '+err.message);
            }
        }

        function exportToMarkdown(messages, filename) {
            try {
                // Validate messages before processing
                if (!messages || !Array.isArray(messages) || messages.length === 0) {
                    throw new Error('No valid messages to export');
                }

                // Filter out invalid messages
                const validMessages = messages.filter(msg => {
                    return msg && 
                           msg.role && 
                           msg.parts && 
                           Array.isArray(msg.parts) && 
                           msg.parts.length > 0 && 
                           msg.parts[0] && 
                           msg.parts[0].text;
                });

                if (validMessages.length === 0) {
                    throw new Error('No valid messages with text content to export');
                }

                const content = validMessages.map(msg => {
                const sender = msg.role === 'user' ? 'You' : 'AI';
                    const text = msg.parts[0].text || '[No content]';
                return `### **${sender}**\n\n${text}\n\n---\n\n`;
            }).join('');
            
            const fullContent = `# Chat Conversation\n\n${content}`;
            downloadFile(fullContent, `${filename}.md`, 'text/markdown');
            } catch (error) {
                console.error('Markdown export error:', error);
                alert('Failed to export markdown: ' + error.message);
            }
        }

        function createExportHTML(messages) {
            const style=`<style>
            body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;line-height:1.6;margin:20px;}
            .message{margin-bottom:20px;padding:15px;border-radius:8px;}
            .user-message{background:#2563eb;color:#fff;margin-left:20%;}
            .ai-message{background:#f8fafc;color:#1f2937;border:1px solid #e5e7eb;}
            .message-content{white-space:normal;}
            .message-content pre{background:#1f2937;color:#f9fafc;padding:12px;border-radius:6px;overflow-x:auto;}
            .message-content code{background:#f3f4f6;color:#dc2626;padding:2px 4px;border-radius:3px;}
            .message-content h1,.message-content h2,.message-content h3{margin:18px 0 10px 0;}
            table{border-collapse:collapse;width:100%;margin:10px 0;}
            th,td{border:1px solid #e5e7eb;padding:8px;text-align:left;}
            th{background:#f9fafb;}
            </style>`;

            const parts=messages.map(msg=>{
                const text=msg.parts[0].text||'';
                const html=window.marked?marked.parse(text):text.replace(/\n/g,'<br>');
                const cls=msg.role==='user'?'user-message':'ai-message';
                return `<div class="message ${cls}"><div class="message-content">${html}</div></div>`;
            }).join('');

            return `<!DOCTYPE html><html><head><meta charset='utf-8'><title>Chat Export</title>${style}</head><body><h1>Chat Conversation</h1>${parts}</body></html>`;
        }





        // Alternative PDF generation using pure text approach
        function createTextBasedPDF(messages, filename) {
            try {
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 20;
                const maxWidth = pageWidth - (2 * margin);
                let yPosition = margin;
                const lineHeight = 6;
                const titleHeight = 12;
                // Title
                pdf.setFontSize(16);
                pdf.setFont('helvetica', 'bold');
                pdf.setTextColor(40, 40, 40);
                pdf.text('Chat Conversation', pageWidth / 2, yPosition, { align: 'center' });
                yPosition += titleHeight;
                // Timestamp
                pdf.setFontSize(10);
                pdf.setFont('helvetica', 'normal');
                pdf.setTextColor(80, 80, 80);
                pdf.text(`Exported on ${new Date().toLocaleString()}`, pageWidth / 2, yPosition, { align: 'center' });
                yPosition += lineHeight * 2;

                messages.forEach(msg => {
                    const sender = msg.role === 'user' ? 'You' : 'AI Assistant';
                    let text = msg.parts[0].text || '[No content]';
                    // Add sender name (ensure space on page first)
                    if (yPosition + lineHeight > pageHeight - margin) {
                        pdf.addPage();
                        yPosition = margin;
                    }
                    pdf.setFontSize(12);
                    pdf.setFont('helvetica', 'bold');
                    pdf.setTextColor(40, 40, 40);
                    pdf.text(sender, margin, yPosition);
                    yPosition += lineHeight;

                    // Process text and split into printable lines
                    text = processTextForPDF(text);
                    const lines = splitTextIntoLines(text, pdf, maxWidth);

                    lines.forEach(line => {
                        // Add page break **before** writing if needed
                        if (yPosition + lineHeight > pageHeight - margin) {
                            pdf.addPage();
                            yPosition = margin;
                        }
                        if (line.startsWith('QUOTE:')) {
                            pdf.setFontSize(9);
                            pdf.setFont('helvetica', 'italic');
                            pdf.setTextColor(100, 100, 100);
                            pdf.text(line.substring(6), margin + 5, yPosition);
                        } else if (line.startsWith('CODE:')) {
                            pdf.setFontSize(9);
                            pdf.setFont('courier', 'normal');
                            pdf.setTextColor(80, 80, 80);
                            pdf.text(line.substring(5), margin + 5, yPosition);
                        } else if (line.startsWith('HEADER:')) {
                            pdf.setFontSize(11);
                            pdf.setFont('helvetica', 'bold');
                            pdf.setTextColor(40, 40, 40);
                            pdf.text(line.substring(7), margin, yPosition);
                        } else if (line === '') {
                            // Blank line  just move cursor
                        } else {
                            pdf.setFontSize(10);
                            pdf.setFont('helvetica', 'normal');
                            pdf.setTextColor(60, 60, 60);
                            pdf.text(line, margin, yPosition);
                        }
                        yPosition += lineHeight;
                    });

                    yPosition += lineHeight; // Extra spacing between messages
                });
                pdf.save(`${filename}.pdf`);
            } catch (error) {
                console.error('Text-based PDF creation error:', error);
                throw new Error('Failed to create text-based PDF: ' + error.message);
            }
        }

        // Process text for better PDF formatting
        function processTextForPDF(text) {
            return text
                // Handle code blocks
                .replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
                    return '\nCODE:' + code.split('\n').join('\nCODE:') + '\n';
                })
                // Handle inline code
                .replace(/`([^`]+)`/g, 'CODE:$1')
                // Handle quotes
                .replace(/^> (.*$)/gm, 'QUOTE:$1')
                // Handle headers
                .replace(/^### (.*$)/gm, 'HEADER:$1')
                .replace(/^## (.*$)/gm, 'HEADER:$1')
                .replace(/^# (.*$)/gm, 'HEADER:$1')
                // Handle bold and italic
                .replace(/\*\*(.*?)\*\*/g, '**$1**')
                .replace(/\*(.*?)\*/g, '*$1*');
        }

        // Split text into lines that fit the page width (uses jsPDF's built-in splitter for reliability)
        function splitTextIntoLines(text, pdf, maxWidth) {
            const lines = [];
            const paragraphs = text.split('\n');
            paragraphs.forEach(paragraph => {
                if (paragraph.trim() === '') {
                    lines.push('');
                    return;
                }
                if (paragraph.startsWith('QUOTE:') || paragraph.startsWith('CODE:') || paragraph.startsWith('HEADER:')) {
                    lines.push(paragraph);
                    return;
                }
                const wrapped = pdf.splitTextToSize(paragraph, maxWidth);
                wrapped.forEach(l => lines.push(l));
            });
            return lines;
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Simple markdown parser for better PDF formatting
        function simpleMarkdownParser(text) {
            return text
                // Headers
                .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                // Bold and italic
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                // Code blocks
                .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                // Lists
                .replace(/^- (.*$)/gm, '<li>$1</li>')
                .replace(/^\d+\. (.*$)/gm, '<li>$1</li>')
                // Blockquotes
                .replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>')
                // Line breaks
                .replace(/\n/g, '<br>');
        }

        // Chat history management
        function loadChats() {
            const stored = localStorage.getItem(STORAGE_KEYS.CHATS);
            if (stored) {
                allChats = JSON.parse(stored);
            }
            
            // Clean up empty chats on app startup
            cleanupEmptyChats();
            
            debouncedRenderChatList();
            
            // Update new chat button state after loading
            updateNewChatButtonState();
            
            if (allChats.length === 0) {
                createNewChat();
            } else {
                // Try to restore the last selected chat
                const lastChatId = localStorage.getItem(STORAGE_KEYS.CURRENT_CHAT);
                const chatExists = allChats.find(c => c.id === lastChatId);
                
                if (lastChatId && chatExists) {
                    selectChat(lastChatId);
                } else {
                    selectChat(allChats[0].id);
                }
            }
        }

        function saveChats() {
            try {
                // Check storage quota before saving
                if (!checkLocalStorageQuota()) {
                    console.warn('[saveChats] Storage quota check failed');
                    showQuotaError();
                    return;
                }

                const sanitized = sanitizeChatsForStorage(allChats);
                const dataToSave = JSON.stringify(sanitized);
                
                // More accurate usage estimation  size of the data that will be stored
                const newUsage = dataToSave.length;
                
                // Warn if approaching quota (5MB limit)
                if (newUsage > 4.5 * 1024 * 1024) {
                    console.warn('[saveChats] Approaching localStorage quota:', newUsage / (1024 * 1024), 'MB');
                }
                
                localStorage.setItem(STORAGE_KEYS.CHATS, dataToSave);
                // Hide quota error if previously shown
                hideQuotaError();
            } catch (e) {
                if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                    console.error('[saveChats] Storage quota exceeded:', e);
                    showQuotaError();
                    
                    // Try to free up space by removing oldest chats
                    if (allChats.length > 1) {
                        const removedChat = allChats.pop(); // Remove oldest chat
                        console.log('[saveChats] Removed oldest chat to free space:', removedChat.title);
                        try {
                            const sanitized = sanitizeChatsForStorage(allChats);
                            localStorage.setItem(STORAGE_KEYS.CHATS, JSON.stringify(sanitized));
                            hideQuotaError();
                            debouncedRenderChatList();
                        } catch (retryError) {
                            console.error('[saveChats] Still cannot save after removing chat:', retryError);
                        }
                    }
                } else {
                    console.error('[saveChats] Failed to save chats:', e);
                    alert('Failed to save chats: ' + e.message);
                }
            }
        }

        // --- NEW: Sanitize chat history for storage (strip base64 data) ---
        function sanitizeChatsForStorage(chats) {
            return chats.map(chat=>({
                ...chat,
                history: chat.history.map(msg=>({
                    ...msg,
                    parts: msg.parts.map(part=>{
                        if(part.inlineData){
                            const {mimeType,fileName,size}=part.inlineData;
                            return { inlineData:{mimeType,fileName,size} };
                        }
                        return part;     // keep full text, no slicing
                    })
                }))
            }));
        }

        // Helper function to check if a chat is empty (only has welcome message)
        function isChatEmpty(chat) {
            if (!chat || !chat.history || chat.history.length === 0) {
                return true;
            }
            
            // Check if chat only has the welcome message (no user messages)
            const hasUserMessages = chat.history.some(msg => msg.role === 'user');
            const hasOnlyWelcomeMessage = chat.history.length === 1 && 
                chat.history[0].role === 'model' && 
                chat.history[0].parts[0].text.includes('Welcome! ');
            
            return !hasUserMessages || hasOnlyWelcomeMessage;
        }

        // Helper function to find the most recent empty chat
        function findMostRecentEmptyChat() {
            return allChats.find(chat => isChatEmpty(chat));
        }

        // Helper function to clean up empty chats (remove all but the most recent one)
        function cleanupEmptyChats() {
            const emptyChats = allChats.filter(chat => isChatEmpty(chat));
            if (emptyChats.length > 1) {
                // Keep only the most recent empty chat, remove the rest
                const chatsToRemove = emptyChats.slice(1); // Remove all but the first one
                chatsToRemove.forEach(chatToRemove => {
                    const idx = allChats.findIndex(c => c.id === chatToRemove.id);
                    if (idx !== -1) {
                        allChats.splice(idx, 1);
                    }
                });
                saveChats();
                debouncedRenderChatList();
            }
        }

        // Helper function to update new chat button state
        function updateNewChatButtonState() {
            const hasEmptyChat = findMostRecentEmptyChat();
            const newChatBtn = elements.newChatBtn;
            
            if (hasEmptyChat) {
                // Show that there's an existing empty chat
                newChatBtn.title = 'Switch to existing empty chat';
                newChatBtn.style.opacity = '0.7';
                newChatBtn.style.cursor = 'pointer';
            } else {
                // Show that a new chat will be created
                newChatBtn.title = 'New Chat';
                newChatBtn.style.opacity = '1';
                newChatBtn.style.cursor = 'pointer';
            }
        }

        function createNewChat() {
            // Clean up any stuck editing state
            if (editingMessageId) {
                cancelMessageEdit(editingMessageId);
            }
            
            // Clear temporary chat state when creating a new regular chat
            tempChatId = null;
            tempChatHistory = [];
            
            // Prevent new chat if quota error
            if (document.getElementById('quotaErrorBanner')) {
                alert('Cannot create new chat: storage is full. Please delete old chats.');
                return;
            }

            // Check if there's already an empty chat
            const existingEmptyChat = findMostRecentEmptyChat();
            if (existingEmptyChat) {
                // Switch to the existing empty chat instead of creating a new one
                selectChat(existingEmptyChat.id);
                elements.chatInput.focus();
                return;
            }

            // Clean up any duplicate empty chats before creating a new one
            cleanupEmptyChats();

            const id = generateId();
            const newChat = {
                id: id,
                title: 'New Chat',
                history: [],
                pinned: false, // NEW
                archived: false // NEW
            };
            allChats.unshift(newChat);
            saveChats();
            selectChat(id);
            debouncedRenderChatList();
            elements.chatInput.focus();
            elements.chatTitle.removeAttribute('data-temp');
        }

        function createTempChat() {
            // Clean up any stuck editing state
            if (editingMessageId) {
                cancelMessageEdit(editingMessageId);
            }
            
            // Generate temporary chat ID
            tempChatId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Clear current chat selection
            currentChatId = null;
            
            // Clear temporary chat history
            tempChatHistory = [];
            
            // Update title to show it's a temporary chat
            elements.chatTitle.textContent = 'Temporary Chat ';
            elements.chatTitle.setAttribute('data-temp', 'true');
            
            // Clear messages
            elements.chatMessages.innerHTML = '';
            
            // Clear chat history
            chatHistory = [];
            
            // Add welcome message for temporary chat
            const welcomeMessage = `# Temporary Chat 

This is a temporary chat session. Your messages will not be saved and will be lost when you navigate away or refresh the page.

Feel free to ask me anything!`;
            addMessage(welcomeMessage, 'ai', null, selectedModel);
            tempChatHistory.push({ role: "model", parts: [{ text: welcomeMessage }], modelUsed: selectedModel });
            
            // Focus on input
            elements.chatInput.focus();
        }

        // Performance optimization: Debounced chat selection
        let selectChatTimeout = null;
        function debouncedSelectChat(chatId) {
            if (selectChatTimeout) {
                clearTimeout(selectChatTimeout);
            }
            selectChatTimeout = setTimeout(() => {
                selectChat(chatId);
                selectChatTimeout = null;
            }, 50);
        }

        function selectChat(chatId) {
            // Clean up any stuck editing state
            if (editingMessageId) {
                cancelMessageEdit(editingMessageId);
            }
            
            // Clear temporary chat state when selecting a regular chat
            if (tempChatId && chatId !== tempChatId) {
                tempChatId = null;
                tempChatHistory = [];
            }
            
            currentChatId = chatId;
            const chat = allChats.find(c => c.id === chatId);
            if (!chat) return;

            // Save current chat ID
            localStorage.setItem(STORAGE_KEYS.CURRENT_CHAT, chatId);

            // Update title
            elements.chatTitle.textContent = chat.title;
            elements.chatTitle.removeAttribute('data-temp');
            
            // Clear messages
            elements.chatMessages.innerHTML = '';
            
            // Load chat history
            chatHistory = [...chat.history];
            
            // Render messages
            if (chatHistory.length === 0) {
                // Add welcome message for new chats
                const welcomeMessage = `# Welcome! 
I'm your AI assistant. How can I help you today?`;
                addMessage(welcomeMessage, 'ai', null, selectedModel);
                chat.history.push({ role: "model", parts: [{ text: welcomeMessage }], modelUsed: selectedModel });
                saveChats();
            } else {
                // Render existing chat history
                chatHistory.forEach(msg => {
                    if (msg.role === 'user') {
                        // Find text part and file parts
                        let text = '';
                        let fileParts = [];
                        msg.parts.forEach(part => {
                            if (part.text) text = part.text;
                            if (part.inlineData) fileParts.push(part);
                        });
                        addMessage(text, 'user', fileParts, null, msg.id);
                    } else if (msg.role === 'model') {
                        // Use the model that was actually used to generate this message
                        const modelUsed = msg.modelUsed || selectedModel;
                        // Check if this is an image message
                        const imageData = msg.imageData || null;
                        addMessage(msg.parts[0].text, 'ai', null, modelUsed, msg.id, imageData);
                    }
                });
                
                // Apply syntax highlighting to all code blocks in the loaded chat
                requestAnimationFrame(() => {
                    if (window.Prism) {
                        elements.chatMessages.querySelectorAll('code[class*="language-"]').forEach(codeElement => {
                            Prism.highlightElement(codeElement);
                        });
                    }
                });
            }
            
            debouncedRenderChatList();
            
            // Restore scroll position after rendering is complete
            requestAnimationFrame(() => {
                restoreScrollPosition();
            });
        }

        // Performance optimization: Debounced render function
        let renderTimeout = null;
        function debouncedRenderChatList() {
            if (renderTimeout) {
                clearTimeout(renderTimeout);
            }
            renderTimeout = setTimeout(() => {
                renderChatList();
                renderTimeout = null;
            }, 100);
        }

        // Optimized chat list rendering with virtual scrolling concept
        function renderChatList() {
            // Clear existing content efficiently
            elements.chatList.innerHTML = '';
            
            // Filter chats based on search query (title only)
            let filteredChats = allChats;
            if (searchQuery.trim()) {
                const query = searchQuery.toLowerCase();
                filteredChats = allChats.filter(chat => {
                    return chat.title.toLowerCase().includes(query);
                });
            }
            
            // Sort: pinned > unpinned > archived
            const pinned = filteredChats.filter(c => c.pinned && !c.archived);
            const unpinned = filteredChats.filter(c => !c.pinned && !c.archived);
            const archived = filteredChats.filter(c => c.archived);

            // Create document fragment for better performance
            const fragment = document.createDocumentFragment();

            function renderChats(chats) {
                chats.forEach(chat => {
                const item = document.createElement('div');
                item.className = `chat-item ${chat.id === currentChatId ? 'active' : ''}`;
                item.tabIndex = 0;
                item.style.position = 'relative';

                    // Pin icon
                    if (chat.pinned) {
                        const pinIcon = document.createElement('span');
                        pinIcon.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-1v5.586l2.293 2.293a1 1 0 0 1-1.414 1.414l-2.293-2.293V7h-1a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h6z"/></svg>`;
                        pinIcon.style.marginRight = '0.5em';
                        pinIcon.style.color = '#60a5fa';
                        item.appendChild(pinIcon);
                    }

                // Chat title or rename input
                if (renamingChatId === chat.id) {
                    const input = document.createElement('input');
                    input.className = 'chat-rename-input';
                    input.value = chat.title;
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            finishRenameChat(chat.id, input.value);
                        } else if (e.key === 'Escape') {
                            renamingChatId = null;
                                debouncedRenderChatList();
                        }
                    });
                    input.addEventListener('blur', () => {
                        finishRenameChat(chat.id, input.value);
                    });
                    setTimeout(() => input.focus(), 10);
                    item.appendChild(input);
                } else {
                    const title = document.createElement('span');
                    title.className = 'chat-title';
                    title.style.flex = '1';
                        title.addEventListener('click', () => debouncedSelectChat(chat.id));
                    
                    // Highlight search term in title if searching
                    if (searchQuery.trim()) {
                        const query = searchQuery.toLowerCase();
                        const titleText = chat.title;
                        const lowerTitle = titleText.toLowerCase();
                        const index = lowerTitle.indexOf(query);
                        
                        if (index !== -1) {
                            const before = titleText.substring(0, index);
                            const match = titleText.substring(index, index + query.length);
                            const after = titleText.substring(index + query.length);
                            
                            title.innerHTML = `${before}<mark style="background: var(--accent); color: white; padding: 0 2px; border-radius: 2px;">${match}</mark>${after}`;
                        } else {
                            title.textContent = titleText;
                        }
                    } else {
                        title.textContent = chat.title;
                    }
                    
                    item.appendChild(title);
                }

                    // Three-dot options button
                    const optionsBtn = document.createElement('button');
                    optionsBtn.className = 'chat-action-btn';
                    optionsBtn.title = 'Options';
                    optionsBtn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="5" cy="12" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="19" cy="12" r="2"/></svg>`;
                    optionsBtn.style.marginLeft = 'auto';
                    optionsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                        showChatOptionsMenu(chat, item, optionsBtn);
                    });
                    item.appendChild(optionsBtn);

                    fragment.appendChild(item);
                });
            }

            // Show search results count if searching
            if (searchQuery.trim()) {
                if (filteredChats.length === 0) {
                    const noResults = document.createElement('div');
                    noResults.style.cssText = `
                        text-align: center;
                        color: var(--sidebar-icon);
                        font-style: italic;
                        padding: 1rem;
                        font-size: 0.875rem;
                    `;
                    noResults.textContent = 'No chats found matching your search.';
                    fragment.appendChild(noResults);
                } else {
                    const resultsCount = document.createElement('div');
                    resultsCount.style.cssText = `
                        text-align: center;
                        color: var(--accent);
                        font-size: 0.75rem;
                        padding: 0.5rem;
                        border-bottom: 1px solid var(--border);
                        margin-bottom: 0.5rem;
                    `;
                    resultsCount.textContent = `Found ${filteredChats.length} chat${filteredChats.length === 1 ? '' : 's'}`;
                    fragment.appendChild(resultsCount);
                }
            }
            
            // Render pinned, then unpinned
            if (pinned.length > 0) {
                renderChats(pinned);
            }
            if (unpinned.length > 0) {
                renderChats(unpinned);
            }
            
            // Update new chat button state
            updateNewChatButtonState();
            
            // Archived section (collapsible)
            if (archived.length > 0) {
                let archivedSection = document.getElementById('archivedChatsSection');
                if (!archivedSection) {
                    archivedSection = document.createElement('div');
                    archivedSection.id = 'archivedChatsSection';
                    archivedSection.style.marginTop = '1.5em';
                    archivedSection.style.borderTop = '1px solid var(--border)';
                    archivedSection.style.paddingTop = '0.5em';
                    archivedSection.style.fontSize = '0.95em';
                    archivedSection.style.color = '#9ca3af';
                    fragment.appendChild(archivedSection);
                }
                archivedSection.innerHTML = '';
                
                // Collapsible header
                const header = document.createElement('div');
                header.textContent = 'Archived';
                header.style.cursor = 'pointer';
                header.style.fontWeight = '600';
                header.style.display = 'flex';
                header.style.alignItems = 'center';
                header.style.gap = '0.5em';
                const arrow = document.createElement('span');
                arrow.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>';
                header.appendChild(arrow);
                archivedSection.appendChild(header);
                
                let expanded = false;
                let archivedList = document.createElement('div');
                archivedList.style.display = 'none';
                archivedSection.appendChild(archivedList);
                
                function toggleArchived() {
                    expanded = !expanded;
                    archivedList.style.display = expanded ? 'block' : 'none';
                    arrow.style.transform = expanded ? 'rotate(180deg)' : 'none';
                }
                header.addEventListener('click', toggleArchived);
                
                // Render archived chats
                archived.forEach(chat => {
                    const item = document.createElement('div');
                    item.className = `chat-item ${chat.id === currentChatId ? 'active' : ''}`;
                    item.tabIndex = 0;
                    item.style.position = 'relative';
                    
                    // Pin icon
                    if (chat.pinned) {
                        const pinIcon = document.createElement('span');
                        pinIcon.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-1v5.586l2.293 2.293a1 1 0 0 1-1.414 1.414l-2.293-2.293V7h-1a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h6z"/></svg>`;
                        pinIcon.style.marginRight = '0.5em';
                        pinIcon.style.color = '#60a5fa';
                        item.appendChild(pinIcon);
                    }
                    
                    // Chat title or rename input
                    if (renamingChatId === chat.id) {
                        const input = document.createElement('input');
                        input.className = 'chat-rename-input';
                        input.value = chat.title;
                        input.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                finishRenameChat(chat.id, input.value);
                            } else if (e.key === 'Escape') {
                                renamingChatId = null;
                                debouncedRenderChatList();
                            }
                        });
                        input.addEventListener('blur', () => {
                            finishRenameChat(chat.id, input.value);
                        });
                        setTimeout(() => input.focus(), 10);
                        item.appendChild(input);
                    } else {
                        const title = document.createElement('span');
                        title.className = 'chat-title';
                        title.style.flex = '1';
                        title.addEventListener('click', () => debouncedSelectChat(chat.id));
                        
                        // Highlight search term in title if searching
                        if (searchQuery.trim()) {
                            const query = searchQuery.toLowerCase();
                            const titleText = chat.title;
                            const lowerTitle = titleText.toLowerCase();
                            const index = lowerTitle.indexOf(query);
                            
                            if (index !== -1) {
                                const before = titleText.substring(0, index);
                                const match = titleText.substring(index, index + query.length);
                                const after = titleText.substring(index + query.length);
                                
                                title.innerHTML = `${before}<mark style="background: var(--accent); color: white; padding: 0 2px; border-radius: 2px;">${match}</mark>${after}`;
                            } else {
                                title.textContent = titleText;
                            }
                        } else {
                            title.textContent = chat.title;
                        }
                        
                        item.appendChild(title);
                    }

                    // Three-dot options button
                    const optionsBtn = document.createElement('button');
                    optionsBtn.className = 'chat-action-btn';
                    optionsBtn.title = 'Options';
                    optionsBtn.innerHTML = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="5" cy="12" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="19" cy="12" r="2"/></svg>`;
                    optionsBtn.style.marginLeft = 'auto';
                    optionsBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showChatOptionsMenu(chat, item, optionsBtn);
                    });
                    item.appendChild(optionsBtn);

                    archivedList.appendChild(item);
                });
            }
            
            // Append all content at once for better performance
            elements.chatList.appendChild(fragment);
        }

        function finishRenameChat(chatId, newTitle) {
            renamingChatId = null;
            const chat = allChats.find(c => c.id === chatId);
            if (!chat) return;
            const clean = newTitle.replace(/\s+/g, ' ').trim();
            if (clean.length > 0) {
                chat.title = clean.length > 30 ? clean.substring(0, 30) + '...' : clean;
                saveChats();
            }
            debouncedRenderChatList();
        }

        function deleteChat(chatId) {
            const idx = allChats.findIndex(c => c.id === chatId);
            if (idx === -1) return;
            allChats.splice(idx, 1);
            if (currentChatId === chatId) {
                // Select next chat or create new
                if (allChats.length > 0) {
                    selectChat(allChats[0].id);
                } else {
                    createNewChat();
                }
            }
            // Always persist the updated chat list to localStorage and refresh UI
            saveChats();
            debouncedRenderChatList();
            deleteConfirmChatId = null;
        }

        // Message handling
        function addMessage(text, sender, fileParts, modelUsed = null, messageId = null, imageData = null) {
            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper';
            const messageIdAttr = messageId || generateId();
            wrapper.dataset.messageId = messageIdAttr;
            
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${sender}-message`;
            bubble.dataset.messageId = messageIdAttr;
            
            if (sender === 'user') {
                // Main prompt text
                const promptDiv = document.createElement('div');
                promptDiv.textContent = text;
                bubble.appendChild(promptDiv);
                
                // If there are file parts, show them
                if (fileParts && fileParts.length > 0) {
                    const fileList = document.createElement('div');
                    fileList.className = 'attached-files-list';
                    fileParts.forEach(part => {
                        if (part.inlineData) {
                            const fileDiv = document.createElement('div');
                            fileDiv.className = 'attached-file-item';
                            // Icon
                            const iconSpan = document.createElement('span');
                            iconSpan.className = 'file-preview-icon';
                            iconSpan.innerHTML = getFileIconSVG({
                                name: part.inlineData.fileName || 'file',
                                type: part.inlineData.mimeType || ''
                            });
                            // Info
                            const infoSpan = document.createElement('span');
                            infoSpan.className = 'attached-file-info';
                            // Show only metadata (no preview if no data)
                            infoSpan.textContent = `${part.inlineData.fileName || 'file'} (${part.inlineData.mimeType ? part.inlineData.mimeType.split('/')[0].toUpperCase() : 'FILE'})`;
                            fileDiv.appendChild(iconSpan);
                            fileDiv.appendChild(infoSpan);
                            fileList.appendChild(fileDiv);
                        }
                    });
                    bubble.appendChild(fileList);
                }
                
                // Add message actions for user messages (delete only for user)
                addMessageActions(bubble, messageIdAttr, text, sender);
                
            } else {
                const content = document.createElement('div');
                content.className = 'message-content';
                // Use marked.js for robust markdown parsing (no debug <pre>)
                try {
                    // Sanitize AI output before injecting into the DOM to prevent XSS
                    content.innerHTML = sanitizeHtml(marked.parse(text || ''));
                    // Enhance code blocks to GPT/Gemini style containers
                    content.querySelectorAll('pre code').forEach(codeBlock => {
                        const pre = codeBlock.parentNode;
                        const langMatch = codeBlock.className.match(/language-([a-z0-9]+)/i);
                        const lang = langMatch ? langMatch[1] : 'text';
                        const wrapper = document.createElement('div');
                        wrapper.className = 'code-block';
                        const header = document.createElement('div');
                        header.className = 'code-header';
                        header.innerHTML = `<div class="code-info"><span class="code-language">${lang}</span></div>`;
                        // Copy button in header
                        const headerCopy = document.createElement('button');
                        headerCopy.className = 'copy-btn';
                        headerCopy.textContent = 'Copy';
                        headerCopy.onclick = () => {
                            copyToClipboard(codeBlock.textContent);
                            headerCopy.textContent = 'Copied!';
                            setTimeout(() => headerCopy.textContent = 'Copy', 1500);
                        };
                        header.appendChild(headerCopy);
                        const codeContent = document.createElement('div');
                        codeContent.className = 'code-content';
                        codeContent.appendChild(pre.cloneNode(true));
                        wrapper.appendChild(header);
                        wrapper.appendChild(codeContent);
                        pre.replaceWith(wrapper);
                    });
                } catch (err) {
                    content.innerHTML = '<div style="color:red">[Markdown parse error]</div>';
                    console.error('[addMessage] Markdown parse error:', err);
                }
                
                bubble.appendChild(content);
                
                // Add image if provided (either from current generation or from localStorage)
                if (imageData) {
                    const imageContainer = document.createElement('div');
                    imageContainer.className = 'generated-image-container';
                    imageContainer.style.cssText = `
                        margin-top: 1rem;
                        text-align: center;
                    `;
                    
                    const img = document.createElement('img');
                    img.src = imageData;
                    img.alt = 'Generated image';
                    img.style.cssText = `
                        max-width: 100%;
                        max-height: 400px;
                        border-radius: 0.5rem;
                        border: 1px solid var(--border);
                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                    `;
                    
                    // Add download button
                    const downloadBtn = document.createElement('button');
                    downloadBtn.textContent = 'Download Image';
                    downloadBtn.className = 'save-btn';
                    downloadBtn.style.cssText = `
                        margin-top: 0.5rem;
                        font-size: 0.9rem;
                        padding: 0.5rem 1rem;
                    `;
                    downloadBtn.onclick = () => {
                        const link = document.createElement('a');
                        link.href = imageData;
                        link.download = `generated-image-${Date.now()}.png`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    };
                    
                    imageContainer.appendChild(img);
                    imageContainer.appendChild(downloadBtn);
                    bubble.appendChild(imageContainer);
                }
                
                // Add model indicator for AI messages
                if (modelUsed && MODELS[modelUsed]) {
                    const modelIndicator = document.createElement('div');
                    modelIndicator.className = 'model-indicator';
                    modelIndicator.textContent = `Generated by ${MODELS[modelUsed].name} (${MODELS[modelUsed].provider})`;
                    bubble.appendChild(modelIndicator);
                }
                
                // No copy functionality for code blocks (removed as requested)
                
                // Add copy functionality for AI messages (but not welcome message)
                if (sender === 'ai' && !text.includes('Welcome to AI Chat Interface')) {
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'message-action-btn';
                    copyBtn.innerHTML = `
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                        </svg>`;
                    copyBtn.title = 'Copy AI response';
                    copyBtn.style.cssText = `
                        position: absolute;
                        top: 8px;
                        right: 8px;
                        opacity: 0;
                        transition: opacity 0.2s;
                        background: rgba(0,0,0,0.1);
                        border-radius: 4px;
                        padding: 4px;
                    `;
                    copyBtn.addEventListener('click', () => {
                        copyToClipboard(text);
                        copyBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>`;
                        copyBtn.style.color = '#10b981';
                        setTimeout(() => {
                            copyBtn.innerHTML = `
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                                </svg>`;
                            copyBtn.style.color = '';
                        }, 2000);
                    });
                    bubble.appendChild(copyBtn);
                    
                    // Show copy button on hover
                    bubble.addEventListener('mouseenter', () => {
                        copyBtn.style.opacity = '1';
                    });
                    bubble.addEventListener('mouseleave', () => {
                        copyBtn.style.opacity = '0';
                    });
                }
            }
            
            wrapper.appendChild(bubble);
            elements.chatMessages.appendChild(wrapper);
            
            // Only auto-scroll to bottom for new messages, not when loading existing chat
            if (chatHistory.length === 0 || chatHistory[chatHistory.length - 1].role === 'user') {
                elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
            }
            saveScrollPosition();
        }
        
        function addMessageActions(bubble, messageId, text, sender) {
            const actions = document.createElement('div');
            actions.className = 'message-actions';
            
            if (sender === 'user') {
                // Edit button
                const editBtn = document.createElement('button');
                editBtn.className = 'message-action-btn';
                editBtn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                        <path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                    </svg>
                `;
                editBtn.title = 'Edit message';
                editBtn.onclick = () => editMessage(messageId, text);
                actions.appendChild(editBtn);
                // Copy button
                const copyBtn = document.createElement('button');
                copyBtn.className = 'message-action-btn';
                copyBtn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                `;
                copyBtn.title = 'Copy message';
                copyBtn.addEventListener('click', () => {
                    copyToClipboard(text);
                    // Show feedback
                    copyBtn.innerHTML = `
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 6L9 17l-5-5"/>
                        </svg>
                    `;
                    copyBtn.style.color = '#10b981';
                    setTimeout(() => {
                        copyBtn.innerHTML = `
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                            </svg>
                        `;
                        copyBtn.style.color = '';
                    }, 2000);
                });
                actions.appendChild(copyBtn);
                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'message-action-btn';
                deleteBtn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3,6 5,6 21,6"/>
                        <path d="M19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"/>
                    </svg>
                `;
                deleteBtn.title = 'Delete message';
                deleteBtn.addEventListener('click', () => deleteMessage(messageId));
                actions.appendChild(deleteBtn);
            } else {
                // AI message  only copy button
                const copyBtn = document.createElement('button');
                copyBtn.className = 'message-action-btn';
                copyBtn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>`;
                copyBtn.title = 'Copy message';
                copyBtn.addEventListener('click', () => {
                    copyToClipboard(text);
                    copyBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>`;
                    copyBtn.style.color = '#10b981';
                    setTimeout(() => {
                        copyBtn.innerHTML = `
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                            </svg>`;
                        copyBtn.style.color = '';
                    }, 2000);
                });
                actions.appendChild(copyBtn);
            }
            bubble.appendChild(actions);
        }
        
        function editMessage(messageId, currentText) {
            if (editingMessageId) return; // Prevent multiple edits
            
            editingMessageId = messageId;
            const messageWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageWrapper) return;
            
            const bubble = messageWrapper.querySelector('.message-bubble');
            if (!bubble) return;
            
            // Find the content to hide
            let contentToHide;
            if (bubble.classList.contains('user-message')) {
                // For user messages, hide the first div (prompt text)
                contentToHide = bubble.querySelector('div');
            } else {
                // For AI messages, hide the content div
                contentToHide = bubble.querySelector('.message-content');
            }
            
            if (!contentToHide) return;
            
            // Store original content for restoration
            const originalContent = contentToHide.cloneNode(true);
            messageWrapper.dataset.originalContent = originalContent.outerHTML;
            
            // Create edit input
            const editInput = document.createElement('textarea');
            editInput.className = 'message-edit-input';
            editInput.value = currentText;
            editInput.rows = Math.max(3, currentText.split('\n').length);
            
            // Replace content with input
            contentToHide.style.display = 'none';
            bubble.insertBefore(editInput, contentToHide);
            
            // Add editing indicator
            const editingIndicator = document.createElement('div');
            editingIndicator.style.cssText = `
                color: var(--accent);
                font-size: 0.875rem;
                font-style: italic;
                margin-bottom: 0.5rem;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            `;
            editingIndicator.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                    <path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                </svg>
                Editing message...
            `;
            bubble.insertBefore(editingIndicator, editInput);
            
            editInput.focus();
            editInput.select();
            
            // Add save/cancel buttons
            const editActions = document.createElement('div');
            editActions.className = 'message-edit-actions';
            editActions.style.cssText = `
                display: flex;
                gap: 0.5rem;
                margin-top: 0.75rem;
                justify-content: flex-end;
            `;
            
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save & Regenerate';
            saveBtn.title = 'Save changes and get new AI response (Ctrl+Enter)';
            saveBtn.className = 'edit-save-btn';
            saveBtn.style.cssText = `
                background: var(--accent);
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 0.375rem;
                cursor: pointer;
                font-size: 0.875rem;
                font-weight: 500;
                transition: all 0.2s ease;
            `;
            saveBtn.addEventListener('click', () => {
                saveBtn.disabled = true;
                saveBtn.textContent = 'Saving...';
                
                try {
                    saveMessageEdit(messageId, editInput.value);
                } catch (error) {
                    console.error('Error saving message:', error);
                    // Reset button state on error
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'Save & Regenerate';
                    alert('Error saving message: ' + error.message);
                }
                
                // Reset button state after 5 seconds as a safety measure
                setTimeout(() => {
                    if (saveBtn.disabled) {
                        saveBtn.disabled = false;
                        saveBtn.textContent = 'Save & Regenerate';
                        console.warn('Save button reset due to timeout');
                    }
                }, 5000);
            });
            
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.title = 'Cancel editing (Escape)';
            cancelBtn.className = 'edit-cancel-btn';
            cancelBtn.style.cssText = `
                background: var(--border);
                color: var(--text);
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 0.375rem;
                cursor: pointer;
                font-size: 0.875rem;
                font-weight: 500;
                transition: all 0.2s ease;
            `;
            cancelBtn.addEventListener('click', () => cancelMessageEdit(messageId));
            
            // Add hover effects
            saveBtn.addEventListener('mouseenter', () => {
                saveBtn.style.background = 'var(--accent-hover)';
            });
            saveBtn.addEventListener('mouseleave', () => {
                saveBtn.style.background = 'var(--accent)';
            });
            
            cancelBtn.addEventListener('mouseenter', () => {
                cancelBtn.style.background = 'var(--input-bg)';
            });
            cancelBtn.addEventListener('mouseleave', () => {
                cancelBtn.style.background = 'var(--border)';
            });
            
            editActions.appendChild(cancelBtn);
            editActions.appendChild(saveBtn);
            bubble.appendChild(editActions);
            
            // Handle Enter key to save, Escape to cancel
            editInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    saveMessageEdit(messageId, editInput.value);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelMessageEdit(messageId);
                }
            });
            
            // Auto-resize textarea
            editInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 200) + 'px';
            });
        }
        function saveMessageEdit(messageId, newText) {
            if (!newText.trim()) {
                alert('Message cannot be empty');
                return;
            }
            
            // Prevent multiple saves
            if (editingMessageId !== messageId || isSavingEdit) {
                console.log('Save blocked - editingMessageId:', editingMessageId, 'isSavingEdit:', isSavingEdit);
                return;
            }
            
            isSavingEdit = true;
            console.log('Starting save process for message:', messageId);
            
            try {
                // Update chat history
                const chat = allChats.find(c => c.id === currentChatId);
                if (chat) {
                    const messageIndex = chat.history.findIndex(msg => msg.id === messageId);
                    if (messageIndex !== -1) {
                        // Update the user message
                        chat.history[messageIndex].parts[0].text = newText;
                        
                                            // Remove all subsequent messages (both user and AI responses) after this user message
                    // This creates a clean branch like Gemini's thread system
                    const messagesToRemove = chat.history.splice(messageIndex + 1);
                    console.log(`Removed ${messagesToRemove.length} subsequent messages from chat history`);
                        
                        // Update chat title if this is the first message
                        if (messageIndex === 0) {
                            chat.title = generateTitle(newText);
                            elements.chatTitle.textContent = chat.title;
                        }
                        
                        saveChats();
                        
                        // Update UI - properly restore the original message display
                        const messageWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
                        if (messageWrapper) {
                            const bubble = messageWrapper.querySelector('.message-bubble');
                            
                            // Remove all edit-related elements first
                            const editingIndicator = bubble.querySelector('div[style*="Editing message"]');
                            const editInput = bubble.querySelector('.message-edit-input');
                            const editActions = bubble.querySelector('.message-edit-actions');
                            
                            if (editingIndicator) editingIndicator.remove();
                            if (editInput) editInput.remove();
                            if (editActions) editActions.remove();
                            
                            // Restore original content for user messages
                            if (bubble.classList.contains('user-message')) {
                                // For user messages, completely recreate the prompt text structure
                                // First, remove any existing prompt divs that might be hidden or corrupted
                                const existingDivs = bubble.querySelectorAll('div');
                                existingDivs.forEach(div => {
                                    if (!div.classList.contains('attached-files-list') && 
                                        !div.classList.contains('message-actions') && 
                                        !div.classList.contains('message-edit-input') &&
                                        !div.classList.contains('message-edit-actions')) {
                                        div.remove();
                                    }
                                });
                                
                                // Create a fresh prompt div
                                const promptDiv = document.createElement('div');
                                promptDiv.textContent = newText;
                                promptDiv.style.display = 'block';
                                promptDiv.style.visibility = 'visible';
                                promptDiv.style.opacity = '1';
                                
                                // Insert it at the beginning of the bubble
                                bubble.insertBefore(promptDiv, bubble.firstChild);
                                
                                // Also ensure any attached files are still visible
                                const fileList = bubble.querySelector('.attached-files-list');
                                if (fileList) {
                                    fileList.style.display = 'flex';
                                }
                            } else {
                                // For AI messages, update the content div
                                const content = bubble.querySelector('.message-content');
                                if (content) {
                                    content.textContent = newText;
                                    content.style.display = 'block';
                                    content.style.visibility = 'visible';
                                    content.style.opacity = '1';
                                }
                            }
                            
                            // Replace message actions to ensure they work with the new text
                            const existingActions = bubble.querySelector('.message-actions');
                            if (existingActions) {
                                existingActions.remove();
                            }
                            addMessageActions(bubble, messageId, newText, 'user');
                        }
                        
                        // Remove subsequent messages from UI
                        const currentMessageIndex = Array.from(elements.chatMessages.children).findIndex(
                            child => child.dataset.messageId === messageId
                        );
                        
                        if (currentMessageIndex !== -1) {
                            const messagesToRemove = Array.from(elements.chatMessages.children).slice(currentMessageIndex + 1);
                            messagesToRemove.forEach(msg => msg.remove());
                            console.log(`Removed ${messagesToRemove.length} subsequent message elements from UI`);
                        }
                        
                        // Update chat history array to match
                        chatHistory.splice(messageIndex + 1);
                        
                        // Save to localStorage to persist the changes (removes subsequent messages from storage)
                        saveChats();
                        console.log('Updated localStorage - removed subsequent messages');
                        
                        // Clear editing state
                        editingMessageId = null;
                        isSavingEdit = false;
                        
                        // Send the edited message immediately
                        console.log('Calling sendEditedMessage with:', newText);
                        sendEditedMessage(newText).then(() => {
                            console.log('sendEditedMessage completed successfully');
                        }).catch((error) => {
                            console.error('sendEditedMessage failed:', error);
                        });
                        
                        // Debug: Log the updated message to ensure it's saved
                        console.log('Message updated:', {
                            messageId: messageId,
                            newText: newText,
                            chatHistory: chat.history[messageIndex]
                        });
                        
                        // Verify the message is visible in the UI
                        setTimeout(() => {
                            const verifyWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
                            if (verifyWrapper) {
                                const verifyBubble = verifyWrapper.querySelector('.message-bubble');
                                const verifyText = verifyBubble.querySelector('div');
                                console.log('Message visibility check:', {
                                    messageId: messageId,
                                    textVisible: verifyText && verifyText.textContent === newText,
                                    textContent: verifyText ? verifyText.textContent : 'No text found'
                                });
                            }
                        }, 100);
                    } else {
                        console.error('Message not found in chat history:', messageId);
                        isSavingEdit = false;
                    }
                } else {
                    console.error('Chat not found:', currentChatId);
                    isSavingEdit = false;
                }
            } catch (error) {
                console.error('Error in saveMessageEdit:', error);
                isSavingEdit = false;
                throw error; // Re-throw to be caught by the click handler
            }
        }
        
        function cancelMessageEdit(messageId) {
            const messageWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageWrapper) return;
            
            const bubble = messageWrapper.querySelector('.message-bubble');
            if (!bubble) return;
            
            // Remove all edit-related elements
            const editingIndicator = bubble.querySelector('div[style*="Editing message"]');
            const editInput = bubble.querySelector('.message-edit-input');
            const editActions = bubble.querySelector('.message-edit-actions');
            
            if (editingIndicator) editingIndicator.remove();
            if (editInput) editInput.remove();
            if (editActions) editActions.remove();
            
            // Restore original content
            if (messageWrapper.dataset.originalContent) {
                // Find the content to restore
                let contentToRestore;
                if (bubble.classList.contains('user-message')) {
                    contentToRestore = bubble.querySelector('div');
                } else {
                    contentToRestore = bubble.querySelector('.message-content');
                }
                
                if (contentToRestore) {
                    contentToRestore.outerHTML = messageWrapper.dataset.originalContent;
                    contentToRestore.style.display = 'block';
                }
                delete messageWrapper.dataset.originalContent;
            } else {
                // Fallback: just show the content
                let contentToShow;
                if (bubble.classList.contains('user-message')) {
                    contentToShow = bubble.querySelector('div');
                } else {
                    contentToShow = bubble.querySelector('.message-content');
                }
                if (contentToShow) {
                    contentToShow.style.display = 'block';
                }
            }
            
            editingMessageId = null;
        }
        
        function deleteMessage(messageId) {
             if (!confirm('Are you sure you want to delete this message and its AI response?')) return;
             
             // Find the chat and message index
             const chat = allChats.find(c => c.id === currentChatId);
             if (!chat) return;
             
             const messageIndex = chat.history.findIndex(msg => msg.id === messageId);
             if (messageIndex === -1) return;
             
             // Get the user message text for fallback search
             const userMessage = chat.history[messageIndex];
             const userText = userMessage.parts[0].text;
             
             // Determine how many messages to remove (user + possible AI response)
             let removeCount = 1;
             let aiMessageId = null;
             
             if (chat.history[messageIndex + 1] && chat.history[messageIndex + 1].role === 'model') {
                 removeCount = 2;
                 aiMessageId = chat.history[messageIndex + 1].id;
             }
             
             // Remove from data structure
             chat.history.splice(messageIndex, removeCount);
             
             // Update localStorage
             try {
                 saveChats();
             } catch (err) {
                 console.error('[deleteMessage] Failed to save after deletion:', err);
             }
             
             // Remove from UI immediately - try multiple selectors for robustness
             let userWrapper = document.querySelector(`[data-message-id="${messageId}"]`);
             if (!userWrapper) {
                 // Fallback: find by message content
                 const allWrappers = document.querySelectorAll('.message-wrapper');
                 for (let wrapper of allWrappers) {
                     const bubble = wrapper.querySelector('.user-message');
                     if (bubble && bubble.textContent.trim() === userText) {
                         userWrapper = wrapper;
                         break;
                     }
                 }
             }
             
             if (userWrapper) {
                 userWrapper.remove();
                 
                 // Remove AI response wrapper if it exists
                 if (aiMessageId) {
                     let aiWrapper = document.querySelector(`[data-message-id="${aiMessageId}"]`);
                     if (!aiWrapper) {
                         // Fallback: find AI response that follows the user message
                         const nextWrapper = userWrapper.nextElementSibling;
                         if (nextWrapper && nextWrapper.querySelector('.ai-message')) {
                             aiWrapper = nextWrapper;
                         }
                     }
                     if (aiWrapper) {
                         aiWrapper.remove();
                     }
                 }
             }
             
             // Update chat history array to match
             chatHistory.splice(messageIndex, removeCount);
             
             console.log(`[deleteMessage] Deleted ${removeCount} messages: user message and ${aiMessageId ? 'AI response' : 'no AI response'}`);
         }

        function parseMarkdown(text) {
            let html = text;
            const localCodeBlocks = [];
            let codeBlockIndex = 0;
            
            // Step 1: Handle escaped characters first (before other parsing)
            html = html.replace(/\\([\\`*_{}\[\]()#+\-!|])/g, (match, char) => {
                return `<span class="escaped-char">${char}</span>`;
            });
            
            // Step 2: Detect code blocks and project structure blocks
            html = html.replace(/```(\w*)\n([\s\S]*?)```|((^\s*[].*\n)+)/gm, (match, lang, code, treeBlock) => {
                if (treeBlock) {
                    // Project structure block
                    const idx = codeBlockIndex++;
                    localCodeBlocks.push({ lang: 'project-structure', code: treeBlock.trim() });
                    return `<button class="show-code-btn" data-code-index="${idx}"><span style='margin-right:0.4em;'></span>Show Project Structure</button>`;
                } else {
                    // Regular code block
                    const idx = codeBlockIndex++;
                    localCodeBlocks.push({ lang: lang || 'text', code: code.trim() });
                    return `<button class="show-code-btn" data-code-index="${idx}">Show ${lang ? lang : 'Code'} Block</button>`;
                }
            });
            
            // Step 3: Parse headers (ATX style)
            html = html.replace(/^#\s+(.*?)(?:\n|$)/gm, '<h1>$1</h1>');
            html = html.replace(/^##\s+(.*?)(?:\n|$)/gm, '<h2>$1</h2>');
            html = html.replace(/^###\s+(.*?)(?:\n|$)/gm, '<h3>$1</h3>');
            html = html.replace(/^####\s+(.*?)(?:\n|$)/gm, '<h4>$1</h4>');
            html = html.replace(/^#####\s+(.*?)(?:\n|$)/gm, '<h5>$1</h5>');
            html = html.replace(/^######\s+(.*?)(?:\n|$)/gm, '<h6>$1</h6>');

            // Step 4: Parse horizontal rules
            html = html.replace(/^---+$/gm, '<hr/>');
            html = html.replace(/^\*\*\*+$/gm, '<hr/>');
            html = html.replace(/^===+$/gm, '<hr/>');

            // Step 5: Parse admonitions/callouts (before blockquotes)
            html = parseAdmonitions(html);

            // Step 6: Parse blockquotes with nesting support
            html = parseBlockquotes(html);

            // Step 7: Parse lists with comprehensive edge case handling
            html = parseLists(html);

            // Step 8: Parse tables
            html = parseTables(html);

            // Step 9: Parse inline formatting (after lists to avoid conflicts)
            html = parseInlineFormatting(html);

            // Step 10: Parse paragraphs with proper empty line handling
            html = parseParagraphs(html);

            // Step 11: Restore code blocks with proper button replacement
            localCodeBlocks.forEach((block, index) => {
                const codeBlockHtml = `
                    <div class="code-block">
                        <div class="code-header">
                            <div class="code-info">
                                <span class="code-language">${block.lang}</span>
                            </div>
                            <button class="copy-btn">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                                </svg>
                                Copy
                            </button>
                        </div>
                        <div class="code-content">
                            <pre><code class="language-${block.lang}">${escapeHtml(block.code)}</code></pre>
                        </div>
                    </div>
                `;
                
                // Find and replace the button with the actual code block
                const buttonPattern = new RegExp(`<button class="show-code-btn" data-code-index="${index}">[^<]*</button>`, 'g');
                html = html.replace(buttonPattern, codeBlockHtml);
            });

            // Step 12: Restore escaped characters
            html = html.replace(/<span class="escaped-char">(.)<\/span>/g, '$1');
            
            // Step 13: Clean up excessive whitespace while preserving intentional spacing
            html = html.replace(/\n{4,}/g, '\n\n\n');
            
            // Step 14: Sanitize HTML to prevent XSS
            html = sanitizeHtml(html);
            
            return html;
        }

        // Comprehensive list parsing function
        function parseLists(md) {
            const lines = md.split(/\r?\n/);
            let result = '';
            let i = 0;
            
            while (i < lines.length) {
                const line = lines[i];
                
                // Check if this line starts a list
                const listMatch = line.match(/^(\s*)([-*+]|\d+\.)\s+(.*)$/);
                
                if (listMatch) {
                    const [fullMatch, indent, marker, content] = listMatch;
                    const indentLevel = indent.replace(/\t/g, '    ').length;
                    const isOrdered = /^\d+\./.test(marker);
                    const listType = isOrdered ? 'ol' : 'ul';
                    
                    // Start the list
                    result += `<${listType}>\n`;
                    
                    // Parse the list items
                    const listItems = [];
                    let currentIndent = indentLevel;
                    let currentType = listType;
                    
                    while (i < lines.length) {
                        const currentLine = lines[i];
                        const itemMatch = currentLine.match(/^(\s*)([-*+]|\d+\.)\s+(.*)$/);
                        
                        if (!itemMatch) {
                            // Check if this is a continuation line (indented content)
                            const continuationMatch = currentLine.match(/^(\s+)(.+)$/);
                            if (continuationMatch && continuationMatch[1].length > indentLevel) {
                                // This is continuation content for the previous list item
                                const continuationContent = continuationMatch[2];
                                if (listItems.length > 0) {
                                    listItems[listItems.length - 1].content += ' ' + continuationContent;
                                }
                                i++;
                                continue;
                            } else {
                                // End of list - but don't break if there's more content after
                                // Check if next line is empty or starts a new block
                                if (i + 1 < lines.length) {
                                    const nextLine = lines[i + 1];
                                    if (nextLine.trim() === '' || 
                                        nextLine.match(/^[#>\-\*\+=]/) || 
                                        nextLine.match(/^```/)) {
                                        break;
                                    }
                                }
                                // If we reach here, continue to next line
                                i++;
                                continue;
                            }
                        }
                        
                        const [fullItemMatch, itemIndent, itemMarker, itemContent] = itemMatch;
                        const itemIndentLevel = itemIndent.replace(/\t/g, '    ').length;
                        const itemIsOrdered = /^\d+\./.test(itemMarker);
                        const itemType = itemIsOrdered ? 'ol' : 'ul';
                        
                        // Check if this is a checklist item
                        const checklistMatch = itemContent.match(/^\[([ x])\]\s*(.*)$/);
                        if (checklistMatch) {
                            const isChecked = checklistMatch[1] === 'x';
                            const checklistContent = checklistMatch[2];
                            listItems.push({
                                content: checklistContent,
                                type: 'checkbox',
                                checked: isChecked,
                                indent: itemIndentLevel
                            });
                        } else {
                            // Regular list item
                            listItems.push({
                                content: itemContent,
                                type: 'regular',
                                indent: itemIndentLevel,
                                listType: itemType
                            });
                        }
                        
                        // If this item contains a code block placeholder, we need to handle it specially
                        if (itemContent.includes('__CODE_BLOCK_')) {
                            // Handle code block placeholders in list items
                        }
                        
                        i++;
                    }
                    
                    // Process list items and handle nesting
                    result += processListItems(listItems, 0);
                    result += `</${listType}>\n`;
                    
                } else {
                    // Not a list line, add as-is
                    result += line + '\n';
                    i++;
                }
            }
            
            return result;
        }

        // Process list items with proper nesting
        function processListItems(items, startIndex) {
            let result = '';
            let i = startIndex;
            
            while (i < items.length) {
                const item = items[i];
                
                if (item.type === 'checkbox') {
                    // Handle checklist items
                    const checkedAttr = item.checked ? ' checked' : '';
                    result += `<li class="task-list-item"><input type="checkbox"${checkedAttr} disabled> ${item.content}</li>\n`;
                } else {
                    // Handle regular list items
                    result += `<li>${item.content}`;
                    
                    // Check for nested content
                    let nestedItems = [];
                    let j = i + 1;
                    
                    while (j < items.length && items[j].indent > item.indent) {
                        nestedItems.push(items[j]);
                        j++;
                    }
                    
                    if (nestedItems.length > 0) {
                        // Group nested items by their list type
                        const nestedGroups = groupNestedItems(nestedItems);
                        
                        nestedGroups.forEach(group => {
                            result += `\n<${group.type}>\n`;
                            result += processListItems(group.items, 0);
                            result += `</${group.type}>\n`;
                        });
                        
                        i = j - 1; // Skip the nested items we just processed
                    }
                    
                    result += '</li>\n';
                }
                
                i++;
            }
            
            return result;
        }

        // Group nested items by their list type
        function groupNestedItems(items) {
            const groups = [];
            let currentGroup = null;
            
            items.forEach(item => {
                if (!currentGroup || currentGroup.type !== item.listType) {
                    if (currentGroup) {
                        groups.push(currentGroup);
                    }
                    currentGroup = {
                        type: item.listType,
                        items: [item]
                    };
                } else {
                    currentGroup.items.push(item);
                }
            });
            
            if (currentGroup) {
                groups.push(currentGroup);
            }
            
            return groups;
        }

        // Parse blockquotes with nesting support
        function parseBlockquotes(md) {
            const lines = md.split(/\r?\n/);
            let result = '';
            let i = 0;
            
            while (i < lines.length) {
                const line = lines[i];
                
                // Check if this line starts a blockquote
                const blockquoteMatch = line.match(/^(>+)\s*(.*)$/);
                
                if (blockquoteMatch) {
                    const [fullMatch, quoteMarkers, content] = blockquoteMatch;
                    const nestingLevel = quoteMarkers.length;
                    
                    // Start the blockquote
                    result += '<blockquote>\n';
                    
                    // Parse the blockquote content
                    const blockquoteLines = [];
                    
                    while (i < lines.length) {
                        const currentLine = lines[i];
                        const currentMatch = currentLine.match(/^(>+)\s*(.*)$/);
                        
                        if (!currentMatch) {
                            // Check if this is a continuation line (empty or content)
                            if (currentLine.trim() === '' || currentLine.startsWith(' ')) {
                                // This is continuation content for the previous blockquote
                                if (blockquoteLines.length > 0) {
                                    blockquoteLines[blockquoteLines.length - 1] += ' ' + currentLine.trim();
                                }
                                i++;
                                continue;
                            } else {
                                // End of blockquote
                                break;
                            }
                        }
                        
                        const [fullCurrentMatch, currentQuoteMarkers, currentContent] = currentMatch;
                        const currentNestingLevel = currentQuoteMarkers.length;
                        
                        // If nesting level changes, we need to handle nested blockquotes
                        if (currentNestingLevel > nestingLevel) {
                            // This is a nested blockquote
                            if (blockquoteLines.length > 0) {
                                // Close the current blockquote content
                                result += blockquoteLines.join('\n') + '\n';
                                blockquoteLines.length = 0;
                            }
                            
                            // Start nested blockquote
                            result += '<blockquote>\n';
                            result += currentContent + '\n';
                            
                            // Continue parsing nested content
                            i++;
                            while (i < lines.length) {
                                const nestedLine = lines[i];
                                const nestedMatch = nestedLine.match(/^(>+)\s*(.*)$/);
                                
                                if (!nestedMatch || nestedMatch[1].length <= nestingLevel) {
                                    // End of nested blockquote
                                    result += '</blockquote>\n';
                                    break;
                                }
                                
                                if (nestedMatch[1].length > currentNestingLevel) {
                                    // Even deeper nesting
                                    result += '<blockquote>\n';
                                    result += nestedMatch[2] + '\n';
                                    i++;
                                    continue;
                                }
                                
                                if (nestedMatch[1].length === currentNestingLevel) {
                                    // Same nesting level
                                    result += nestedMatch[2] + '\n';
                                    i++;
                                    continue;
                                }
                                
                                if (nestedMatch[1].length < currentNestingLevel) {
                                    // Closing nested blockquote
                                    result += '</blockquote>\n';
                                    if (nestedMatch[1].length === nestingLevel) {
                                        // Back to original level
                                        result += nestedMatch[2] + '\n';
                                        i++;
                                        break;
                                    }
                                }
                                
                                i++;
                            }
                        } else if (currentNestingLevel === nestingLevel) {
                            // Same nesting level
                            blockquoteLines.push(currentContent);
                            i++;
                        } else {
                            // Lower nesting level - end of this blockquote
                            break;
                        }
                    }
                    
                    // Add remaining blockquote content
                    if (blockquoteLines.length > 0) {
                        result += blockquoteLines.join('\n') + '\n';
                    }
                    
                    result += '</blockquote>\n';
                    
                } else {
                    // Not a blockquote line, add as-is
                    result += line + '\n';
                    i++;
                }
            }
            
            return result;
        }

        // Parse tables
        function parseTables(md) {
            const lines = md.split(/\r?\n/);
            let result = '';
            let i = 0;
            
            while (i < lines.length) {
                const line = lines[i];
                
                // Check if this line looks like a table header
                const tableMatch = line.match(/^\|(.+)\|$/);
                
                if (tableMatch) {
                    // This might be a table, check the next line for separator
                    if (i + 1 < lines.length) {
                        const separatorLine = lines[i + 1];
                        const separatorMatch = separatorLine.match(/^\|([\s\-\|:]+)\|$/);
                        
                        if (separatorMatch) {
                            // This is definitely a table
                            const headers = parseTableRow(tableMatch[1]);
                            const alignments = parseTableSeparator(separatorMatch[1]);
                            
                            result += '<div class="table-container">\n<table>\n<thead>\n<tr>\n';
                            
                            // Add headers
                            headers.forEach((header, index) => {
                                const alignment = alignments[index] || 'left';
                                result += `<th style="text-align: ${alignment}">${header.trim()}</th>\n`;
                            });
                            
                            result += '</tr>\n</thead>\n<tbody>\n';
                            
                            // Skip the separator line
                            i += 2;
                            
                            // Parse table rows
                            while (i < lines.length) {
                                const rowLine = lines[i];
                                const rowMatch = rowLine.match(/^\|(.+)\|$/);
                                
                                if (!rowMatch) {
                                    // End of table
                                    break;
                                }
                                
                                const cells = parseTableRow(rowMatch[1]);
                                result += '<tr>\n';
                                
                                cells.forEach((cell, index) => {
                                    const alignment = alignments[index] || 'left';
                                    result += `<td style="text-align: ${alignment}">${cell.trim()}</td>\n`;
                                });
                                
                                result += '</tr>\n';
                                i++;
                            }
                            
                            result += '</tbody>\n</table>\n</div>\n';
                            
                        } else {
                            // Not a table, just a line with pipes
                            result += line + '\n';
                            i++;
                        }
                    } else {
                        // No next line, not a table
                        result += line + '\n';
                        i++;
                    }
                } else {
                    // Not a table line, add as-is
                    result += line + '\n';
                    i++;
                }
            }
            
            return result;
        }

        // Helper function to parse table row
        function parseTableRow(row) {
            return row.split('|').map(cell => cell.trim());
        }

        // Helper function to parse table separator and determine alignments
        function parseTableSeparator(separator) {
            const cells = separator.split('|').map(cell => cell.trim());
            return cells.map(cell => {
                if (cell.startsWith(':') && cell.endsWith(':')) {
                    return 'center';
                } else if (cell.endsWith(':')) {
                    return 'right';
                } else {
                    return 'left';
                }
            });
        }
        // Parse admonitions/callouts
        function parseAdmonitions(md) {
            const lines = md.split(/\r?\n/);
            let result = '';
            let i = 0;
            
            while (i < lines.length) {
                const line = lines[i];
                
                // Check for admonition patterns
                const admonitionMatch = line.match(/^>\s*\*\*([]+[^:]*):\*\*\s*(.*)$/);
                
                if (admonitionMatch) {
                    const [fullMatch, icon, content] = admonitionMatch;
                    
                    // Determine admonition type based on icon
                    let admonitionType = 'info'; // default
                    if (icon.includes('')) admonitionType = 'tip';
                    else if (icon.includes('')) admonitionType = 'warning';
                    else if (icon.includes('')) admonitionType = 'error';
                    else if (icon.includes('')) admonitionType = 'success';
                    else if (icon.includes('')) admonitionType = 'info';
                    
                    // Start the admonition
                    result += `<div class="admonition ${admonitionType}">\n`;
                    result += `<div class="admonition-header">${icon}</div>\n`;
                    result += '<div class="admonition-content">\n';
                    result += content + '\n';
                    
                    // Continue parsing admonition content
                    i++;
                    while (i < lines.length) {
                        const currentLine = lines[i];
                        
                        // Check if this is continuation of the admonition
                        if (currentLine.match(/^>\s+(.+)$/)) {
                            const continuationMatch = currentLine.match(/^>\s+(.+)$/);
                            result += continuationMatch[1] + '\n';
                            i++;
                        } else if (currentLine.trim() === '') {
                            // Empty line within admonition
                            result += '\n';
                            i++;
                        } else {
                            // End of admonition
                            break;
                        }
                    }
                    
                    result += '</div>\n</div>\n';
                    
                } else {
                    // Not an admonition line, add as-is
                    result += line + '\n';
                    i++;
                }
            }
            
            return result;
        }

        // Parse inline formatting with enhanced mixed formatting support
        function parseInlineFormatting(text) {
            // Handle mixed formatting patterns first (more specific patterns)
            
            // Bold and Italic combinations (various patterns)
            text = text.replace(/\*\*\*([^*]+?)\*\*\*/g, '<strong><em>$1</em></strong>');
            text = text.replace(/___([^_]+?)___/g, '<strong><em>$1</em></strong>');
            text = text.replace(/\*\*_([^*_]+?)_\*\*/g, '<strong><em>$1</em></strong>');
            text = text.replace(/_(\*\*[^*]+?\*\*)_/g, '<em><strong>$1</strong></em>');
            
            // Bold with strikethrough
            text = text.replace(/\*\*~~([^*~]+?)~~\*\*/g, '<strong><del>$1</del></strong>');
            text = text.replace(/~~\*\*([^*~]+?)\*\*~~/g, '<del><strong>$1</strong></del>');
            
            // Italic with strikethrough
            text = text.replace(/\*~~([^*~]+?)~~\*/g, '<em><del>$1</del></em>');
            text = text.replace(/~~\*([^*~]+?)\*~~/g, '<del><em>$1</em></del>');
            
            // Bold
            text = text.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/__([^_]+?)__/g, '<strong>$1</strong>');
            
            // Italic
            text = text.replace(/\*([^*]+?)\*/g, '<em>$1</em>');
            text = text.replace(/_([^_]+?)_/g, '<em>$1</em>');
            
            // Strikethrough
            text = text.replace(/~~([^~]+?)~~/g, '<del>$1</del>');
            
            // Inline code (handle code with formatting inside)
            text = text.replace(/`([^`]+?)`/g, '<code>$1</code>');
            
            return text;
        }

        // Parse paragraphs with enhanced empty line handling
        function parseParagraphs(text) {
            // Split into blocks, preserving intentional spacing
            const blocks = text.split(/\n{2,}/);
            
            return blocks.map(block => {
                const trimmed = block.trim();
                if (!trimmed) return '';
                
                // Skip if already a block element or contains code block placeholders
                if (trimmed.startsWith('<') && 
                    (trimmed.startsWith('<h') || 
                     trimmed.startsWith('<ul') || 
                     trimmed.startsWith('<ol') || 
                     trimmed.startsWith('<blockquote') || 
                     trimmed.startsWith('<div') || 
                     trimmed.startsWith('<table') ||
                     trimmed.startsWith('<hr') ||
                     trimmed.startsWith('<admonition'))) {
                    return trimmed;
                }
                
                // Skip if this block contains code block placeholders
                if (trimmed.includes('__CODE_BLOCK_')) {
                    return trimmed;
                }
                
                // Handle long lines by adding soft breaks for readability
                const processedContent = trimmed
                    .replace(/\n/g, '<br>')
                    // Add soft breaks for very long lines (optional, for readability)
                    .replace(new RegExp(`(.{${CONFIG.LONG_LINE_THRESHOLD},}?)(\\s)`, 'g'), '$1$2');
                
                return `<p>${processedContent}</p>`;
            }).join('\n\n');
        }

        // Enhanced HTML escaping with XSS protection
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Sanitize HTML content to prevent XSS
        function sanitizeHtml(html) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            
            // Remove potentially dangerous elements and attributes
            const dangerousTags = ['script', 'iframe', 'object', 'embed', 'form', 'input', 'textarea', 'select', 'button'];
            const dangerousAttrs = ['onclick', 'onload', 'onerror', 'onmouseover', 'onfocus', 'onblur', 'onchange', 'onsubmit'];
            
            dangerousTags.forEach(tag => {
                tempDiv.querySelectorAll(tag).forEach(el => el.remove());
            });
            
            dangerousAttrs.forEach(attr => {
                tempDiv.querySelectorAll(`[${attr}]`).forEach(el => {
                    el.removeAttribute(attr);
                });
            });
            
            return tempDiv.innerHTML;
        }
        


        function showLoading(message = 'AI is thinking') {
            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper loading-wrapper';
            
            const loading = document.createElement('div');
            loading.className = 'loading-indicator';
            loading.innerHTML = `
                <span>${message}</span>
                <div class="loading-dots">
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                </div>
            `;
            
            wrapper.appendChild(loading);
            elements.chatMessages.appendChild(wrapper);
            
            // Always scroll to bottom when showing loading (new message being sent)
            elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
            
            return wrapper;
        }
        
        function showFileUploadProgress(fileName, progress) {
            let progressElement = document.getElementById('fileUploadProgress');
            if (!progressElement) {
                progressElement = document.createElement('div');
                progressElement.id = 'fileUploadProgress';
                progressElement.className = 'file-upload-progress';
                progressElement.innerHTML = `
                    <div class="upload-status">Processing ${fileName}...</div>
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                    </div>
                    <div class="upload-status">0%</div>
                `;
                elements.imagePreviewContainer.parentNode.insertBefore(progressElement, elements.imagePreviewContainer);
            }
            
            const progressFill = progressElement.querySelector('.progress-fill');
            const statusText = progressElement.querySelector('.upload-status:last-child');
            const statusLabel = progressElement.querySelector('.upload-status:first-child');
            
            progressFill.style.width = `${progress}%`;
            statusText.textContent = `${Math.round(progress)}%`;
            
            if (progress < 50) {
                statusLabel.textContent = `Processing ${fileName}...`;
            } else if (progress < 100) {
                statusLabel.textContent = `Converting ${fileName}...`;
            } else {
                statusLabel.textContent = `Completed ${fileName}`;
                setTimeout(() => {
                    progressElement.remove();
                }, 1500);
            }
        }

        function removeLoading() {
            const loadingWrapper = elements.chatMessages.querySelector('.loading-wrapper');
            if (loadingWrapper) {
                loadingWrapper.remove();
            }
        }

        // Save scroll position
        function saveScrollPosition() {
            const scrollTop = elements.chatMessages.scrollTop;
            // Only save if it's a meaningful scroll position (not at the very top)
            if (scrollTop > 0) {
                localStorage.setItem(STORAGE_KEYS.SCROLL_POSITION, scrollTop.toString());
            }
        }

        // Restore scroll position
        function restoreScrollPosition() {
            const savedScroll = localStorage.getItem(STORAGE_KEYS.SCROLL_POSITION);
            if (savedScroll && savedScroll !== '0') {
                // Use requestAnimationFrame to ensure DOM is ready
                requestAnimationFrame(() => {
                    elements.chatMessages.scrollTop = parseInt(savedScroll);
                });
            } else {
                // Default to bottom if no saved position or position is 0
                requestAnimationFrame(() => {
                    elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
                });
            }
        }

        // API interaction
        async function sendEditedMessage(editedText) {
            // Ensure we're not in editing mode anymore
            if (editingMessageId) {
                editingMessageId = null;
            }
            
            const model = MODELS[selectedModel];
            if (!model) {
                openModal();
                return;
            }
            
            // Check for appropriate API key
            if (model.format === 'gemini' && !currentApiKey) {
                alert('Please set your Gemini API key in settings');
                openModal();
                return;
            } else if (model.format === 'openai' && !currentOpenRouterApiKey) {
                alert('Please set your OpenRouter API key in settings');
                openModal();
                return;
            }
            
            // Prevent using image generation model for regular chat
            if (model.format === 'gemini-image') {
                alert('Please use the image generation button (camera icon) to generate images, or switch to a different model for text chat.');
                return;
            }
            
            // Show loading with specific message
            const loadingMessage = 'Regenerating response...';
            const loadingWrapper = showLoading(loadingMessage);
            
            console.log('[sendEditedMessage] Sending edited message:', editedText);
            try {
                let aiResponse;
                if (model.format === 'gemini') {
                    // Gemini API
                    const contents = chatHistory.concat([{ role: "user", parts: [{ text: editedText }] }]);
                    const apiContents = stripFileNameFromContents(contents);
                    const requestBody = {
                        contents: apiContents,
                        generationConfig: {
                            temperature: 0.7,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: CONFIG.MAX_OUTPUT_TOKENS,
                        }
                    };
                    console.log('[sendEditedMessage] Gemini API request body:', requestBody);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), responseTimeoutSec * 1000);
                    try {
                        const response = await fetch(`${model.endpoint}?key=${currentApiKey}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log('[sendEditedMessage] Gemini API response status:', response.status);
                        if (!response.ok) {
                            const errorData = await response.json();
                            console.error('[sendEditedMessage] Gemini API error:', errorData);
                            throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        console.log('[sendEditedMessage] Gemini API response data:', data);
                        if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                            aiResponse = data.candidates[0].content.parts[0].text;
                        } else {
                            console.error('[sendEditedMessage] Gemini API: Invalid response format', data);
                            throw new Error('Invalid response format from API');
                        }
                        if (!aiResponse || aiResponse.length < 10) {
                            console.warn('[sendEditedMessage] Gemini API: Response is very short or empty:', aiResponse);
                        }
                        if (aiResponse && aiResponse.match(/(\n|\r|\r\n)$/) === null) {
                            console.warn('[sendEditedMessage] Gemini API: Response may be truncated or incomplete:', aiResponse);
                        }
                    } catch (err) {
                        clearTimeout(timeoutId);
                        throw err;
                    }
                } else if (model.format === 'openai') {
                    // OpenRouter API (Grok 3)
                    const messages = [];
                    chatHistory.forEach(msg => {
                        if (msg.role === 'user') {
                            const content = [];
                            msg.parts.forEach(part => {
                                if (part.text) {
                                    content.push({ type: 'text', text: part.text });
                                } else if (part.inlineData) {
                                    content.push({ 
                                        type: 'text', 
                                        text: `[Attached file: ${part.inlineData.fileName || 'file'} (${part.inlineData.mimeType})]` 
                                    });
                                }
                            });
                            if (content.length > 0) {
                                messages.push({ role: 'user', content });
                            }
                        } else if (msg.role === 'model') {
                            messages.push({ role: 'assistant', content: msg.parts[0].text });
                        }
                    });
                    messages.push({ role: 'user', content: [{ type: 'text', text: editedText }] });
                    const requestBody = {
                        model: 'x-ai/grok-3-beta',
                        messages,
                        max_tokens: CONFIG.MAX_TOKENS,
                    };
                    console.log('[sendEditedMessage] OpenRouter API request body:', requestBody);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), responseTimeoutSec * 1000);
                    try {
                        const response = await fetch(model.endpoint, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${currentOpenRouterApiKey}`,
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(requestBody),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log('[sendEditedMessage] OpenRouter API response status:', response.status);
                        if (!response.ok) {
                            let errorMessage = `HTTP error! status: ${response.status}`;
                            try {
                                const errorData = await response.json();
                                errorMessage = errorData.error?.message || errorData.message || errorMessage;
                                if (errorMessage.includes('credits') || errorMessage.includes('max_tokens')) {
                                    errorMessage += '\n\n Tip: Visit https://openrouter.ai/settings/credits to upgrade your account or reduce max_tokens.';
                                }
                                console.error('[sendEditedMessage] OpenRouter API error:', errorData);
                            } catch (parseError) {
                                try {
                                    const errorText = await response.text();
                                    errorMessage = errorText || errorMessage;
                                    console.error('[sendEditedMessage] OpenRouter API error (text):', errorText);
                                } catch (textError) {}
                            }
                            throw new Error(errorMessage);
                        }
                        const data = await response.json();
                        console.log('[sendEditedMessage] OpenRouter API response data:', data);
                        if (data.choices && data.choices[0] && data.choices[0].message) {
                            aiResponse = data.choices[0].message.content;
                        } else {
                            console.error('[sendEditedMessage] OpenRouter API: Invalid response format', data);
                            throw new Error('Invalid response format from API');
                        }
                        if (!aiResponse || aiResponse.length < 10) {
                            console.warn('[sendEditedMessage] OpenRouter API: Response is very short or empty:', aiResponse);
                        }
                        if (aiResponse && aiResponse.match(/(\n|\r|\r\n)$/) === null) {
                            console.warn('[sendEditedMessage] OpenRouter API: Response may be truncated or incomplete:', aiResponse);
                        }
                    } catch (err) {
                        clearTimeout(timeoutId);
                        throw err;
                    }
                }
                removeLoading();
                console.log('[sendEditedMessage] AI response:', aiResponse);
                addMessage(aiResponse, 'ai', null, selectedModel);
                const aiMessageId = generateId();
                chatHistory.push({ id: aiMessageId, role: "model", parts: [{ text: aiResponse }], modelUsed: selectedModel });
                updateCurrentChat({ id: aiMessageId, role: "model", parts: [{ text: aiResponse }], modelUsed: selectedModel });
            } catch (error) {
                removeLoading();
                console.error('[sendEditedMessage] Error:', error);
                let errorMessage = 'An error occurred while processing your request.';
                if (error.message.includes('API key')) {
                    errorMessage = 'Invalid API key. Please check your settings.';
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    errorMessage = 'Network error. Please check your internet connection.';
                } else if (error.message.includes('timeout')) {
                    errorMessage = 'Request timed out. Please try again.';
                } else if (error.message.includes('quota') || errorMessage.includes('credits')) {
                    errorMessage = 'API quota exceeded. Please check your account limits.';
                } else {
                    errorMessage = `Error: ${error.message}`;
                }
                addMessage(errorMessage, 'ai');
            }
        }

        async function sendMessage(message) {
            const model = MODELS[selectedModel];
            if (!model) {
                openModal();
                return;
            }
            // Check for appropriate API key
            if (model.format === 'gemini' && !currentApiKey) {
                alert('Please set your Gemini API key in settings');
                openModal();
                return;
            } else if (model.format === 'openai' && !currentOpenRouterApiKey) {
                alert('Please set your OpenRouter API key in settings');
                openModal();
                return;
            }
            
            // Prevent using image generation model for regular chat
            if (model.format === 'gemini-image') {
                alert('Please use the image generation button (camera icon) to generate images, or switch to a different model for text chat.');
                return;
            }
            const userMessage = message.trim();
            if (!userMessage && selectedFiles.length === 0) return; // Allow sending only files
            // Check for files with Grok 3 (text only)
            if (model.format === 'openai' && selectedFiles.length > 0) {
                const fileNames = selectedFiles.map(f => f.name).join(', ');
                if (!confirm(`Grok 3 currently only supports text. The following files will be noted but not processed: ${fileNames}\n\nContinue anyway?`)) {
                    return;
                }
            }
            // Prepare user parts
            let userParts = [];
            if (userMessage) {
                userParts.push({ text: userMessage });
            }
            if (selectedFiles.length > 0) {
                const fileParts = await Promise.all(selectedFiles.map(async (file, index) => {
                    showFileUploadProgress(file.name, 10);
                    await new Promise(resolve => setTimeout(resolve, 200));
                    showFileUploadProgress(file.name, 30);
                    const base64Data = await fileToBase64(file);
                    await new Promise(resolve => setTimeout(resolve, 300));
                    showFileUploadProgress(file.name, 70);
                    await new Promise(resolve => setTimeout(resolve, 200));
                    showFileUploadProgress(file.name, 100);
                    return {
                        inlineData: {
                            mimeType: file.type,
                            data: base64Data,
                            fileName: file.name,
                            size: file.size
                        }
                    };
                }));
                userParts = userParts.concat(fileParts.filter(p => p.inlineData && p.inlineData.data));
            }
            if (userParts.length === 0) return;
            if (userMessage || userParts.some(p => p.inlineData)) {
                const fileParts = userParts.filter(p => p.inlineData);
                addMessage(userMessage, 'user', fileParts);
            }
            elements.chatInput.value = '';
            selectedFiles = [];
            elements.fileInput.value = '';
            renderImagePreviews();
            elements.sendBtn.disabled = true;
            let loadingMessage = 'AI is thinking...';
            if (selectedFiles.length > 0) {
                loadingMessage = 'Processing files and generating response...';
            } else if (userMessage.length > 500) {
                loadingMessage = 'Analyzing your message and generating response...';
            }
            const loadingWrapper = showLoading(loadingMessage);
            console.log('[sendMessage] Sending message:', userMessage, userParts);
            try {
                let aiResponse;
                if (model.format === 'gemini') {
                    // Add system prompt if customization is set
                    let contents = chatHistory.concat([{ role: "user", parts: userParts }]);
                    
                    // Add system message at the beginning if customization exists
                    const systemPrompt = generateSystemPrompt();
                    if (systemPrompt !== "You are a helpful AI assistant. Provide helpful, accurate, and personalized responses.") {
                        contents = [{ role: "user", parts: [{ text: systemPrompt }] }].concat(contents);
                    }
                    
                    const apiContents = stripFileNameFromContents(contents);
                    const requestBody = {
                        contents: apiContents,
                        generationConfig: {
                            temperature: 0.7,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: CONFIG.MAX_OUTPUT_TOKENS,
                        }
                    };
                    console.log('[sendMessage] Gemini API request body:', requestBody);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), responseTimeoutSec * 1000);
                    try {
                        const response = await fetch(`${model.endpoint}?key=${currentApiKey}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log('[sendMessage] Gemini API response status:', response.status);
                        if (!response.ok) {
                            const errorData = await response.json();
                            console.error('[sendMessage] Gemini API error:', errorData);
                            throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        console.log('[sendMessage] Gemini API response data:', data);
                        if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                            aiResponse = data.candidates[0].content.parts[0].text;
                        } else {
                            console.error('[sendMessage] Gemini API: Invalid response format', data);
                            throw new Error('Invalid response format from API');
                        }
                        if (!aiResponse || aiResponse.length < 10) {
                            console.warn('[sendMessage] Gemini API: Response is very short or empty:', aiResponse);
                        }
                        if (aiResponse && aiResponse.match(/(\n|\r|\r\n)$/) === null) {
                            console.warn('[sendMessage] Gemini API: Response may be truncated or incomplete:', aiResponse);
                        }
                    } catch (err) {
                        clearTimeout(timeoutId);
                        throw err;
                    }
                } else if (model.format === 'openai') {
                    const messages = [];
                    
                    // Add system message if customization exists
                    const systemPrompt = generateSystemPrompt();
                    if (systemPrompt !== "You are a helpful AI assistant. Provide helpful, accurate, and personalized responses.") {
                        messages.push({ role: 'system', content: systemPrompt });
                    }
                    
                    chatHistory.forEach(msg => {
                        if (msg.role === 'user') {
                            const content = [];
                            msg.parts.forEach(part => {
                                if (part.text) {
                                    content.push({ type: 'text', text: part.text });
                                } else if (part.inlineData) {
                                    content.push({ 
                                        type: 'text', 
                                        text: `[Attached file: ${part.inlineData.fileName || 'file'} (${part.inlineData.mimeType})]` 
                                    });
                                }
                            });
                            if (content.length > 0) {
                                messages.push({ role: 'user', content });
                            }
                        } else if (msg.role === 'model') {
                            messages.push({ role: 'assistant', content: msg.parts[0].text });
                        }
                    });
                    const currentContent = [];
                    userParts.forEach(part => {
                        if (part.text) {
                            currentContent.push({ type: 'text', text: part.text });
                        } else if (part.inlineData) {
                            currentContent.push({ 
                                type: 'text', 
                                text: `[Attached file: ${part.inlineData.fileName || 'file'} (${part.inlineData.mimeType})]` 
                            });
                        }
                    });
                    if (currentContent.length > 0) {
                        messages.push({ role: 'user', content: currentContent });
                    }
                    const requestBody = {
                        model: 'x-ai/grok-3-beta',
                        messages,
                        max_tokens: CONFIG.MAX_TOKENS,
                    };
                    console.log('[sendMessage] OpenRouter API request body:', requestBody);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), responseTimeoutSec * 1000);
                    try {
                        const response = await fetch(model.endpoint, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${currentOpenRouterApiKey}`,
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(requestBody),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        console.log('[sendMessage] OpenRouter API response status:', response.status);
                        if (!response.ok) {
                            let errorMessage = `HTTP error! status: ${response.status}`;
                            try {
                                const errorData = await response.json();
                                errorMessage = errorData.error?.message || errorData.message || errorMessage;
                                if (errorMessage.includes('credits') || errorMessage.includes('max_tokens')) {
                                    errorMessage += '\n\n Tip: Visit https://openrouter.ai/settings/credits to upgrade your account or reduce max_tokens.';
                                }
                                console.error('[sendMessage] OpenRouter API error:', errorData);
                            } catch (parseError) {
                                try {
                                    const errorText = await response.text();
                                    errorMessage = errorText || errorMessage;
                                    console.error('[sendMessage] OpenRouter API error (text):', errorText);
                                } catch (textError) {}
                            }
                            throw new Error(errorMessage);
                        }
                        const data = await response.json();
                        console.log('[sendMessage] OpenRouter API response data:', data);
                        if (data.choices && data.choices[0] && data.choices[0].message) {
                            aiResponse = data.choices[0].message.content;
                        } else {
                            console.error('[sendMessage] OpenRouter API: Invalid response format', data);
                            throw new Error('Invalid response format from API');
                        }
                        if (!aiResponse || aiResponse.length < 10) {
                            console.warn('[sendMessage] OpenRouter API: Response is very short or empty:', aiResponse);
                        }
                        if (aiResponse && aiResponse.match(/(\n|\r|\r\n)$/) === null) {
                            console.warn('[sendMessage] OpenRouter API: Response may be truncated or incomplete:', aiResponse);
                        }
                    } catch (err) {
                        clearTimeout(timeoutId);
                        throw err;
                    }
                }
                removeLoading();
                console.log('[sendMessage] AI response:', aiResponse);
                addMessage(aiResponse, 'ai', null, selectedModel);
                const userMessageId = generateId();
                const aiMessageId = generateId();
                
                // Handle temporary chat vs regular chat
                if (tempChatId && currentChatId === null) {
                    // Temporary chat - store in memory only
                    tempChatHistory.push({ id: userMessageId, role: "user", parts: userParts, type: "text" });
                    tempChatHistory.push({ id: aiMessageId, role: "model", parts: [{ text: aiResponse }], modelUsed: selectedModel, type: "text" });
                    chatHistory.push({ id: userMessageId, role: "user", parts: userParts, type: "text" });
                    chatHistory.push({ id: aiMessageId, role: "model", parts: [{ text: aiResponse }], modelUsed: selectedModel, type: "text" });
                } else {
                    // Regular chat - save to localStorage
                    chatHistory.push({ id: userMessageId, role: "user", parts: userParts, type: "text" });
                    chatHistory.push({ id: aiMessageId, role: "model", parts: [{ text: aiResponse }], modelUsed: selectedModel, type: "text" });
                    updateCurrentChat({ id: userMessageId, role: "user", parts: userParts, type: "text" });
                    updateCurrentChat({ id: aiMessageId, role: "model", parts: [{ text: aiResponse }], modelUsed: selectedModel, type: "text" });
                }
            } catch (error) {
                removeLoading();
                console.error('[sendMessage] Error:', error);
                let errorMessage = 'An error occurred while processing your request.';
                if (error.message.includes('API key')) {
                    errorMessage = 'Invalid API key. Please check your settings.';
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    errorMessage = 'Network error. Please check your internet connection.';
                } else if (error.message.includes('timeout')) {
                    errorMessage = 'Request timed out. Please try again.';
                } else if (error.message.includes('quota') || errorMessage.includes('credits')) {
                    errorMessage = 'API quota exceeded. Please check your account limits.';
                } else {
                    errorMessage = `Error: ${error.message}`;
                }
                addMessage(errorMessage, 'ai');
            } finally {
                elements.sendBtn.disabled = false;
                elements.chatInput.focus();
            }
        }
        
        // Helper function to convert blob to data URL for localStorage storage
        function blobToDataURL(blob, callback) {
            const reader = new FileReader();
            reader.onload = function(e) { 
                callback(e.target.result); 
            };
            reader.readAsDataURL(blob);
        }

        // Helper function to strip file names and modelUsed from contents (for Gemini API)
        function stripFileNameFromContents(contentsArr) {
            return contentsArr.map(msg => {
                if (!msg.parts) {
                    // For messages without parts, only keep role and parts, remove modelUsed
                    const { role, parts } = msg;
                    return { role, parts };
                }
                return {
                    role: msg.role,
                    parts: msg.parts
                        .filter(part => (part.text && part.text.trim()) || (part.inlineData && part.inlineData.data))
                        .map(part => {
                            if (part.inlineData && part.inlineData.data) {
                                return {
                                    inlineData: {
                                        mimeType: part.inlineData.mimeType,
                                        data: part.inlineData.data
                                    }
                                };
                            }
                            if (part.text && part.text.trim()) {
                                return { text: part.text };
                            }
                            return null;
                        })
                        .filter(Boolean)
                };
            });
        }

        // Event listeners
        elements.toggleSidebarBtn.addEventListener('click', () => {
            isSidebarOpen = !isSidebarOpen;
            if (window.innerWidth <= CONFIG.MOBILE_BREAKPOINT) {
                elements.sidebar.classList.toggle('mobile-open');
            } else {
                elements.sidebar.classList.toggle('sidebar-collapsed');
            }
        });

        elements.newChatBtn.addEventListener('click', createNewChat);
        elements.tempChatBtn.addEventListener('click', createTempChat);
        elements.importBtn.addEventListener('click', importChats);
        elements.settingsBtn.addEventListener('click', openModal);
        elements.exportBtn.addEventListener('click', openExportModal);
        elements.modalClose.addEventListener('click', closeModal);
        elements.saveApiKeyBtn.addEventListener('click', saveApiKey);
        
        // Model selector change handler
        elements.modelSelector.addEventListener('change', () => {
            selectedModel = elements.modelSelector.value;
            localStorage.setItem(STORAGE_KEYS.SELECTED_MODEL, selectedModel);
            updateApiKeySection();
            updateImageGenerationButton();
        });

        // Search functionality
        elements.chatSearchInput.addEventListener('input', debounce((e) => {
            searchQuery = e.target.value;
            elements.clearSearchBtn.style.display = searchQuery ? 'block' : 'none';
            debouncedRenderChatList();
        }, 300));

        elements.clearSearchBtn.addEventListener('click', () => {
            searchQuery = '';
            elements.chatSearchInput.value = '';
            elements.clearSearchBtn.style.display = 'none';
            debouncedRenderChatList();
        });
        // Keyboard shortcut for search (Ctrl/Cmd + F)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                elements.chatSearchInput.focus();
                elements.chatSearchInput.select();
            }
        });

        // New: File attachment event listeners
        elements.attachFileBtn.addEventListener('click', () => {
            elements.fileInput.click(); // Trigger hidden file input
        });
        elements.fileInput.addEventListener('change', handleFileSelect);

        // Image generation event listener
        elements.generateImageBtn.addEventListener('click', () => {
            openImageGenerationModal();
        });

        elements.sendBtn.addEventListener('click', () => {
            sendMessage(elements.chatInput.value);
        });

        elements.chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage(elements.chatInput.value);
            }
        });

        // Auto-resize textarea and update send button state
        elements.chatInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
            
            // Update send button state
            const hasText = this.value.trim().length > 0;
            const hasFiles = selectedFiles.length > 0;
            elements.sendBtn.disabled = !hasText && !hasFiles;
        });

        // Close modal when clicking outside
        if (elements.apiKeyModal) {
            elements.apiKeyModal.addEventListener('click', (e) => {
                if (e.target === elements.apiKeyModal) {
                    closeModal();
                }
            });
        }

        // Keyboard navigation for modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (elements.apiKeyModal && elements.apiKeyModal.classList.contains('visible')) {
                    closeModal();
                } else if (elements.customizationModal && elements.customizationModal.classList.contains('visible')) {
                    closeCustomizationModal();
                } else if (elements.imageGenerationModal && elements.imageGenerationModal.classList.contains('visible')) {
                    closeImageGenerationModal();
                } else if (elements.exportModal && elements.exportModal.classList.contains('visible')) {
                    closeExportModal();
                } else if (elements.chatDeleteModal && elements.chatDeleteModal.classList.contains('visible')) {
                    closeChatDeleteModal();
                } else if (elements.codeModalOverlay && elements.codeModalOverlay.classList.contains('visible')) {
                    closeCodeModal();
                }
            }
        });

        // Close customization modal when clicking outside
        if (elements.customizationModal) {
            elements.customizationModal.addEventListener('click', (e) => {
                if (e.target === elements.customizationModal) {
                    closeCustomizationModal();
                }
            });
        }

        // Close image generation modal when clicking outside
        if (elements.imageGenerationModal) {
            elements.imageGenerationModal.addEventListener('click', (e) => {
                if (e.target === elements.imageGenerationModal) {
                    closeImageGenerationModal();
                }
            });
        }

        // Close export modal when clicking outside
        if (elements.exportModal) {
            elements.exportModal.addEventListener('click', (e) => {
                if (e.target === elements.exportModal) {
                    closeExportModal();
                }
            });
        }

        // Close chat delete modal when clicking outside
        if (elements.chatDeleteModal) {
            elements.chatDeleteModal.addEventListener('click', (e) => {
                if (e.target === elements.chatDeleteModal) {
                    closeChatDeleteModal();
                }
            });
        }

        // Close code modal when clicking outside
        if (elements.codeModalOverlay) {
            elements.codeModalOverlay.addEventListener('click', (e) => {
                if (e.target === elements.codeModalOverlay) {
                    closeCodeModal();
                }
            });
        }

        // Handle API key input enter
        if (elements.apiKeyInput) {
            elements.apiKeyInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveApiKey();
                }
            });
        }

        // Responsive sidebar handling
        window.addEventListener('resize', () => {
            if (window.innerWidth > CONFIG.MOBILE_BREAKPOINT) {
                if (elements.sidebar) {
                    elements.sidebar.classList.remove('mobile-open');
                    if (isSidebarOpen) {
                        elements.sidebar.classList.remove('sidebar-collapsed');
                    }
                }
            }
        });

        // Chat Delete Modal logic
        function openChatDeleteModal() {
            elements.chatDeleteModal.classList.add('visible');
        }
        function closeChatDeleteModal() {
            elements.chatDeleteModal.classList.remove('visible');
            deleteConfirmChatId = null;
            debouncedRenderChatList();
        }
        if (elements.chatDeleteModalClose) {
            elements.chatDeleteModalClose.addEventListener('click', closeChatDeleteModal);
        }
        if (elements.chatDeleteCancelBtn) {
            elements.chatDeleteCancelBtn.addEventListener('click', closeChatDeleteModal);
        }
        if (elements.chatDeleteConfirmBtn) {
            elements.chatDeleteConfirmBtn.addEventListener('click', function() {
                if (deleteConfirmChatId) {
                    deleteChat(deleteConfirmChatId);
                    closeChatDeleteModal();
                }
            });
        }
        // Close modal when clicking outside
        if (elements.chatDeleteModal) {
            elements.chatDeleteModal.addEventListener('click', (e) => {
                if (e.target === elements.chatDeleteModal) {
                    closeChatDeleteModal();
                }
            });
        }

        // Export modal event listeners
        if (elements.exportModalClose) {
            elements.exportModalClose.addEventListener('click', closeExportModal);
        }
        if (elements.exportCancelBtn) {
            elements.exportCancelBtn.addEventListener('click', closeExportModal);
        }
        if (elements.exportConfirmBtn) {
            elements.exportConfirmBtn.addEventListener('click', exportChatToFormat);
        }
        if (elements.exportModal) {
            elements.exportModal.addEventListener('click', (e) => {
                if (e.target === elements.exportModal) {
                    closeExportModal();
                }
            });
        }

        // Image Generation modal event listeners
        if (elements.imageGenerationModalClose) {
            elements.imageGenerationModalClose.addEventListener('click', closeImageGenerationModal);
        }
        if (elements.imageGenerationCancelBtn) {
            elements.imageGenerationCancelBtn.addEventListener('click', closeImageGenerationModal);
        }
        if (elements.generateImageConfirmBtn) {
            elements.generateImageConfirmBtn.addEventListener('click', () => {
                generateImage(elements.imagePromptInput.value);
            });
        }
        if (elements.downloadImageBtn) {
            elements.downloadImageBtn.addEventListener('click', downloadGeneratedImage);
        }
        if (elements.regenerateImageBtn) {
            elements.regenerateImageBtn.addEventListener('click', () => {
                generateImage(elements.imagePromptInput.value);
            });
        }
        if (elements.imageGenerationModal) {
            elements.imageGenerationModal.addEventListener('click', (e) => {
                if (e.target === elements.imageGenerationModal) {
                    closeImageGenerationModal();
                }
            });
        }
        // Handle Enter key in image prompt input
        if (elements.imagePromptInput) {
            elements.imagePromptInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    generateImage(elements.imagePromptInput.value);
                }
            });
        }

        // Reference image functionality
        if (elements.uploadReferenceBtn && elements.referenceImageInput) {
            elements.uploadReferenceBtn.addEventListener('click', () => {
                elements.referenceImageInput.click();
            });
        }

        if (elements.referenceImageInput) {
            elements.referenceImageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        if (elements.referenceImage) elements.referenceImage.src = event.target.result;
                        if (elements.referenceImageName) elements.referenceImageName.textContent = file.name;
                        if (elements.referenceImagePreview) elements.referenceImagePreview.classList.add('visible');
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        if (elements.removeReferenceBtn) {
            elements.removeReferenceBtn.addEventListener('click', () => {
                if (elements.referenceImage) elements.referenceImage.src = '';
                if (elements.referenceImageName) elements.referenceImageName.textContent = '';
                if (elements.referenceImagePreview) elements.referenceImagePreview.classList.remove('visible');
                if (elements.referenceImageInput) elements.referenceImageInput.value = '';
                console.log('[removeReferenceBtn] Reference image cleared');
            });
        }

        // Theme switching
        const themeSelector = document.getElementById('themeSelector');
        const themeBtns = themeSelector ? themeSelector.querySelectorAll('.theme-option') : [];
        function setTheme(theme) {
            document.body.classList.remove('theme-night', 'theme-light', 'theme-dim');
            document.body.classList.add('theme-' + theme);
            localStorage.setItem(STORAGE_KEYS.THEME, theme);
            // Update active button
            themeBtns.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.theme === theme);
            });
        }
        function loadTheme() {
            const saved = localStorage.getItem(STORAGE_KEYS.THEME);
            if (saved && ['night','light','dim'].includes(saved)) {
                setTheme(saved);
            } else {
                setTheme('night');
            }
        }
        if (themeBtns.length) {
            themeBtns.forEach(btn => {
                btn.addEventListener('click', () => setTheme(btn.dataset.theme));
            });
        }
        loadTheme();

        // Initialize app
        function init() {
            loadApiKey();
            loadChats();
            
            // Sync UI with localStorage
            syncUIWithModel();
            
            // Focus input on load
            elements.chatInput.focus();
            
            // Initialize send button state
            elements.sendBtn.disabled = true;
            
            // Reset any stuck edit buttons
            resetStuckEditButtons();
            
            // Initialize image generation button visibility
            updateImageGenerationButton();
            
            // Initialize Prism.js for syntax highlighting
            if (window.Prism) {
                Prism.highlightAll();
            }
            
            // Show API key modal if no key is set for selected model
            const model = MODELS[selectedModel];
            if ((model.format === 'gemini' && !currentApiKey) || 
                (model.format === 'openai' && !currentOpenRouterApiKey)) {
                setTimeout(() => {
                    openModal();
                }, CONFIG.MODAL_DELAY);
            }
        }

        function syncUIWithModel() {
            // Update model selector to match localStorage
            if (elements.modelSelector) {
                elements.modelSelector.value = selectedModel;
            }
            
            // Update UI based on selected model
            updateApiKeySection();
            updateImageGenerationButton();
        }

        // Function to reset any stuck edit buttons
        function resetStuckEditButtons() {
            // Reset any stuck save buttons
            document.querySelectorAll('.edit-save-btn').forEach(btn => {
                if (btn.disabled) {
                    btn.disabled = false;
                    btn.textContent = 'Save & Regenerate';
                }
            });
            
            // Reset any stuck editing states
            if (editingMessageId) {
                editingMessageId = null;
            }
            if (isSavingEdit) {
                isSavingEdit = false;
            }
        }

        // Start the app
        init();
        
        // Global error handler to reset stuck states
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            resetStuckEditButtons();
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            resetStuckEditButtons();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            clearImagePreviews();
            // Clear temporary chat data
            tempChatId = null;
            tempChatHistory = [];
        });

        // Apply theme and UI updates on app load
        window.addEventListener('DOMContentLoaded', () => {
            loadTheme();
        });
        
        // Apply syntax highlighting when Prism.js is loaded
        window.addEventListener('load', () => {
            if (window.Prism) {
                // Apply highlighting to all existing code blocks
                document.querySelectorAll('code[class*="language-"]').forEach(codeElement => {
                    Prism.highlightElement(codeElement);
                });
            }
        });



        function updateCurrentChat(entry) {
            // Handle temporary chat
            if (tempChatId && currentChatId === null) {
                tempChatHistory.push(entry);
                return; // Don't save to localStorage for temporary chats
            }
            
            const chat = allChats.find(c => c.id === currentChatId);
            if (!chat) return;

            // Update title if this is the first user message
            if (chat.title === 'New Chat' && entry.role === 'user') {
                chat.title = generateTitle(entry.parts[0].text);
                elements.chatTitle.textContent = chat.title;
            }

            chat.history.push(entry);
            saveChats();
            renderChatList();

            // If this chat was previously empty and now has user messages, clean up other empty chats
            if (entry.role === 'user') {
                cleanupEmptyChats();
                updateNewChatButtonState();
            }
        }

        function removeImagePreview(index) {
            selectedFiles.splice(index, 1);
            renderImagePreviews();
            elements.fileInput.value = '';
        }

        // Export/Import functionality
        function exportChat(chat) {
            try {
                // Validate chat object
                if (!chat) {
                    throw new Error('No chat provided for export');
                }
                
                // Ensure chat has required properties with fallbacks
                const safeChat = {
                    id: chat.id || generateId(),
                    title: chat.title || 'Untitled Chat',
                    history: chat.history || [],
                    pinned: chat.pinned || false,
                    archived: chat.archived || false
                };
                
                const exportData = {
                    version: '1.0',
                    exportedAt: new Date().toISOString(),
                    chat: safeChat
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // Safe filename generation
                const safeTitle = safeChat.title.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'untitled_chat';
                const date = new Date().toISOString().split('T')[0];
                a.download = `${safeTitle}_${date}.json`;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                addMessage(`Chat "${safeChat.title}" exported successfully!`, 'ai');
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export chat: ' + error.message);
            }
        }
        
        function importChats() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.multiple = true;
            
            input.onchange = (e) => {
                const files = Array.from(e.target.files);
                let importedCount = 0;
                
                files.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            
                            // Validate import data
                            if (!data.chat || !data.chat.history) {
                                throw new Error('Invalid chat format');
                            }
                            
                            // Create new chat with imported data
                            const importedChat = {
                                id: generateId(),
                                title: data.chat.title || 'Imported Chat',
                                history: data.chat.history || [],
                                pinned: false,
                                archived: false
                            };
                            
                            allChats.unshift(importedChat);
                            importedCount++;
                            
                            if (importedCount === files.length) {
                                saveChats();
                                debouncedRenderChatList();
                                addMessage(`Successfully imported ${importedCount} chat(s)!`, 'ai');
                            }
                        } catch (error) {
                            console.error('Import error:', error);
                            alert(`Failed to import ${file.name}: ${error.message}`);
                        }
                    };
                    reader.readAsText(file);
                });
            };
            
            input.click();
        }

        // --- NEW: Quota error UI ---
        function showQuotaError() {
            if (document.getElementById('quotaErrorBanner')) return;
            const banner = document.createElement('div');
            banner.id = 'quotaErrorBanner';
            banner.style.position = 'fixed';
            banner.style.top = '0';
            banner.style.left = '0';
            banner.style.right = '0';
            banner.style.background = '#ef4444';
            banner.style.color = '#fff';
            banner.style.zIndex = '2000';
            banner.style.padding = '1rem';
            banner.style.textAlign = 'center';
            banner.style.fontWeight = 'bold';
            banner.innerHTML = 'Storage full! Please delete old chats or files to continue.';
            document.body.appendChild(banner);
        }
        function hideQuotaError() {
            const banner = document.getElementById('quotaErrorBanner');
            if (banner) banner.remove();
        }

        // Helper function to check localStorage quota and manage storage
        function checkLocalStorageQuota() {
            try {
                const testKey = '__storage_test__';
                const testData = 'x'.repeat(1024 * 1024); // 1MB test
                localStorage.setItem(testKey, testData);
                localStorage.removeItem(testKey);
                return true;
            } catch (e) {
                console.warn('localStorage quota warning:', e);
                return false;
            }
        }

        // Helper function to estimate localStorage usage
        function estimateStorageUsage() {
            let totalSize = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    totalSize += localStorage[key].length;
                }
            }
            return totalSize;
        }

        // Helper function to format storage size
        function formatStorageSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Helper function to show storage info
        function showStorageInfo() {
            const usage = estimateStorageUsage();
            const usageFormatted = formatStorageSize(usage);
            const maxStorage = '5 MB';
            const percentage = (usage / (5 * 1024 * 1024)) * 100;
            
            alert(`Storage Usage: ${usageFormatted} / ${maxStorage} (${percentage.toFixed(1)}% used)\n\nThis includes all your chat history and generated images.`);
        }

        // --- NEW: Chat options dropdown menu (floating, ChatGPT style) ---
        let openOptionsMenu = null;
        function showChatOptionsMenu(chat, item, btn) {
            // Close any open menu
            if (openOptionsMenu) {
                openOptionsMenu.remove();
                openOptionsMenu = null;
            }
            // Dropdown menu
            const menu = document.createElement('div');
            menu.className = 'chat-options-menu';
            menu.style.position = 'absolute';
            menu.style.minWidth = '160px';
            menu.style.zIndex = '9999';
            menu.style.background = 'var(--card)';
            menu.style.border = '1px solid var(--border)';
            menu.style.borderRadius = '0.5em';
            menu.style.boxShadow = '0 8px 32px rgba(0,0,0,0.18), 0 1.5px 4px rgba(0,0,0,0.08)';
            menu.style.padding = '0.3em 0';
            menu.style.display = 'flex';
            menu.style.flexDirection = 'column';
            menu.style.gap = '0';
            menu.style.fontSize = '1em';
            // Option: Pin/Unpin
            const pinOpt = document.createElement('button');
            pinOpt.className = 'chat-options-menu-item';
            pinOpt.textContent = chat.pinned ? 'Unpin' : 'Pin';
            pinOpt.addEventListener('click', (e) => {
                e.stopPropagation();
                chat.pinned = !chat.pinned;
                saveChats();
                debouncedRenderChatList();
                menu.remove();
            });
            menu.appendChild(pinOpt);
            // Option: Archive/Unarchive
            const archiveOpt = document.createElement('button');
            archiveOpt.className = 'chat-options-menu-item';
            archiveOpt.textContent = chat.archived ? 'Unarchive' : 'Archive';
            archiveOpt.addEventListener('click', (e) => {
                e.stopPropagation();
                chat.archived = !chat.archived;
                if (chat.archived) chat.pinned = false;
                saveChats();
                debouncedRenderChatList();
                menu.remove();
            });
            menu.appendChild(archiveOpt);
            // Option: Rename
            const renameOpt = document.createElement('button');
            renameOpt.className = 'chat-options-menu-item';
            renameOpt.textContent = 'Rename';
            renameOpt.addEventListener('click', (e) => {
                e.stopPropagation();
                renamingChatId = chat.id;
                debouncedRenderChatList();
                menu.remove();
            });
            menu.appendChild(renameOpt);
            // Option: Export
            const exportOpt = document.createElement('button');
            exportOpt.className = 'chat-options-menu-item';
            exportOpt.textContent = 'Export';
            exportOpt.addEventListener('click', (e) => {
                e.stopPropagation();
                exportChat(chat);
                menu.remove();
            });
            menu.appendChild(exportOpt);
            
            // Option: Delete
            const deleteOpt = document.createElement('button');
            deleteOpt.className = 'chat-options-menu-item';
            deleteOpt.textContent = 'Delete';
            deleteOpt.style.color = '#ef4444';
            deleteOpt.addEventListener('click', (e) => {
                e.stopPropagation();
                if (allChats.length === 1) {
                    alert('You must have at least one chat.');
                    return;
                }
                deleteConfirmChatId = chat.id;
                openChatDeleteModal();
                menu.remove();
            });
            menu.appendChild(deleteOpt);
            // Position menu below the button
            const rect = btn.getBoundingClientRect();
            const scrollY = window.scrollY || window.pageYOffset;
            const scrollX = window.scrollX || window.pageXOffset;
            menu.style.left = (rect.left + scrollX) + 'px';
            menu.style.top = (rect.bottom + 6 + scrollY) + 'px';
            // Remove menu on click outside, scroll, or resize
            function closeMenuOnEvent(e) {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('mousedown', closeMenuOnEvent);
                    window.removeEventListener('scroll', closeMenuOnEvent, true);
                    window.removeEventListener('resize', closeMenuOnEvent);
                    openOptionsMenu = null;
                }
            }
            setTimeout(() => {
                document.addEventListener('mousedown', closeMenuOnEvent);
                window.addEventListener('scroll', closeMenuOnEvent, true);
                window.addEventListener('resize', closeMenuOnEvent);
            }, 0);
            // Remove any previous menu
            if (openOptionsMenu) openOptionsMenu.remove();
            openOptionsMenu = menu;
            document.body.appendChild(menu);
        }

        // --- DRAG & DROP AND PASTE FILE SUPPORT ---
        // Visual overlay for drag-and-drop
        let dragOverlay = null;
        function showDragOverlay() {
            if (!dragOverlay) {
                dragOverlay = document.createElement('div');
                dragOverlay.style.position = 'fixed';
                dragOverlay.style.top = '0';
                dragOverlay.style.left = '0';
                dragOverlay.style.right = '0';
                dragOverlay.style.bottom = '0';
                dragOverlay.style.background = 'rgba(37,99,235,0.12)';
                dragOverlay.style.zIndex = '2000';
                dragOverlay.style.display = 'flex';
                dragOverlay.style.alignItems = 'center';
                dragOverlay.style.justifyContent = 'center';
                dragOverlay.style.pointerEvents = 'none';
                dragOverlay.innerHTML = '<div style="background:rgba(37,99,235,0.9);color:#fff;padding:2rem 3rem;border-radius:1rem;font-size:1.5rem;font-weight:600;box-shadow:0 8px 32px rgba(0,0,0,0.18)">Drop files to attach</div>';
            }
            document.body.appendChild(dragOverlay);
        }
        function hideDragOverlay() {
            if (dragOverlay && dragOverlay.parentNode) dragOverlay.parentNode.removeChild(dragOverlay);
        }
        // Drag & drop listeners
        let dragCounter = 0;
        function handleDragEnter(e) {
            if (!isFileModelSelected()) return;
            e.preventDefault();
            dragCounter++;
            showDragOverlay();
        }
        function handleDragOver(e) {
            if (!isFileModelSelected()) return;
            e.preventDefault();
        }
        function handleDragLeave(e) {
            if (!isFileModelSelected()) return;
            dragCounter--;
            if (dragCounter <= 0) {
                hideDragOverlay();
                dragCounter = 0;
            }
        }
        async function handleDrop(e) {
            if (!isFileModelSelected()) {
                hideDragOverlay();
                dragCounter = 0;
                showModelFileError();
                return;
            }
            e.preventDefault();
            hideDragOverlay();
            dragCounter = 0;
            if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                await addFilesToSelection(e.dataTransfer.files);
            }
        }
        async function addFilesToSelection(fileList) {
            for (const file of Array.from(fileList)) {
                const validation = validateFileType(file);
                if (!validation.valid) {
                    showFileTypeError(file, validation.error);
                    continue;
                }
                
                // Process file for conversion if needed
                const processedFile = await processFileForAPI(file);
                selectedFiles.push(processedFile);
            }
            renderImagePreviews();
        }
        // --- Office File Conversion Functions ---
        
        // Show conversion notification
        const showConversionNotification = (fileName, fileType) => {
            const notification = document.createElement('div');
            notification.className = 'conversion-notification';
            notification.innerHTML = `
                <div class="conversion-content">
                    <span class="conversion-icon"></span>
                    <span class="conversion-text">Converting ${fileName} to compatible format...</span>
                </div>
            `;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--card);
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 12px 16px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                animation: slideIn 0.3s ease;
            `;
            
            // Add animation styles if not already present
            if (!document.querySelector('#conversion-styles')) {
                const style = document.createElement('style');
                style.id = 'conversion-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    .conversion-content {
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    }
                    .conversion-icon {
                        font-size: 16px;
                    }
                    .conversion-text {
                        font-size: 14px;
                        color: var(--text);
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 3000);
        };

        // Show conversion result
        const showConversionResult = (originalName, convertedName) => {
            const notification = document.createElement('div');
            notification.className = 'conversion-result';
            notification.innerHTML = `
                <div class="conversion-content">
                    <span class="conversion-icon"></span>
                    <span class="conversion-text">Converted ${originalName}  ${convertedName}</span>
                </div>
            `;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--card);
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 12px 16px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                animation: slideIn 0.3s ease;
            `;
            document.body.appendChild(notification);
            
            // Remove notification after 4 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 4000);
        };

        // Show conversion error notification
        const showConversionError = (fileName) => {
            const notification = document.createElement('div');
            notification.className = 'conversion-error';
            notification.innerHTML = `
                <div class="conversion-content">
                    <span class="conversion-icon"></span>
                    <span class="conversion-text">Failed to convert ${fileName}. Using original file.</span>
                </div>
            `;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #dc2626;
                color: white;
                border-radius: 8px;
                padding: 12px 16px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                animation: slideIn 0.3s ease;
            `;
            document.body.appendChild(notification);
            
            // Remove notification after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        };

        // Convert Word documents to text
        const convertWordToText = async (file) => {
            try {
                // Check if mammoth is available
                if (typeof mammoth === 'undefined') {
                    console.warn('Mammoth library not loaded for Word conversion');
                    return file;
                }

                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({ arrayBuffer });
                
                // Create a simple text file with the content
                const textContent = `Word Document: ${file.name}\n\n${result.value}`;
                const textBlob = new Blob([textContent], { type: 'text/plain' });
                return new File([textBlob], file.name.replace(/\.[^/.]+$/, '.txt'), { type: 'text/plain' });
            } catch (error) {
                console.warn('Word conversion failed:', error);
                return file;
            }
        };

        // Convert Excel files to text
        const convertExcelToText = async (file) => {
            try {
                // Check if XLSX is available
                if (typeof XLSX === 'undefined') {
                    console.warn('XLSX library not loaded for Excel conversion');
                    return file;
                }

                const arrayBuffer = await file.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                
                // Create a text representation of the Excel data
                let textContent = `Excel Workbook: ${file.name}\n\n`;
                
                workbook.SheetNames.forEach((sheetName, sheetIndex) => {
                    textContent += `=== Sheet: ${sheetName} ===\n`;
                    
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    if (jsonData.length === 0) {
                        textContent += '(Empty sheet)\n\n';
                        return;
                    }
                    
                    // Add table data as text
                    jsonData.forEach((row, rowIndex) => {
                        if (Array.isArray(row)) {
                            const rowText = row.map(cell => cell ? String(cell) : '').join('\t');
                            textContent += rowText + '\n';
                        }
                    });
                    
                    textContent += '\n';
                });
                
                const textBlob = new Blob([textContent], { type: 'text/plain' });
                return new File([textBlob], file.name.replace(/\.[^/.]+$/, '.txt'), { type: 'text/plain' });
            } catch (error) {
                console.warn('Excel conversion failed:', error);
                return file;
            }
        };

        // Convert PowerPoint files to text
        const convertPowerPointToText = async (file) => {
            try {
                // Create a text file with information about the PowerPoint file
                const textContent = `PowerPoint Presentation: ${file.name}\n\n` +
                    `File: ${file.name}\n` +
                    `Size: ${formatFileSize(file.size)}\n` +
                    `Type: ${file.name.split('.').pop().toUpperCase()}\n\n` +
                    `Note: This PowerPoint file has been converted to text format.\n` +
                    `The AI will process the file content for analysis and discussion.\n` +
                    `For best results with complex presentations, consider manually\n` +
                    `converting to PDF with full formatting preserved.\n\n` +
                    `Converted on: ${new Date().toLocaleString()}`;
                
                const textBlob = new Blob([textContent], { type: 'text/plain' });
                return new File([textBlob], file.name.replace(/\.[^/.]+$/, '.txt'), { type: 'text/plain' });
            } catch (error) {
                console.warn('PowerPoint conversion failed:', error);
                return file;
            }
        };

        // Main Office file conversion function
        const convertOfficeToText = async (file) => {
            const fileExt = file.name.split('.').pop().toLowerCase();
            
            try {
                // For Word documents
                if (fileExt === 'docx' || fileExt === 'doc') {
                    return await convertWordToText(file);
                }
                
                // For Excel files
                if (fileExt === 'xlsx' || fileExt === 'xls') {
                    return await convertExcelToText(file);
                }
                
                // For PowerPoint files
                if (fileExt === 'pptx' || fileExt === 'ppt') {
                    return await convertPowerPointToText(file);
                }
                
            } catch (error) {
                console.warn('Conversion failed:', error);
                // Return original file if conversion fails
                return file;
            }
            
            return file;
        };

        // Enhanced file processing with conversion
        const processFileForAPI = async (file) => {
            // Show conversion progress if needed
            const fileExt = file.name.split('.').pop().toLowerCase();
            const needsConversion = ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'].includes(fileExt);
            
            if (needsConversion) {
                try {
                    // Show conversion notification
                    showConversionNotification(file.name, fileExt);
                    
                    showFileUploadProgress(file.name, 20);
                    showFileUploadProgress(file.name, 40);
                    
                    // Convert the file
                    const convertedFile = await convertOfficeToText(file);
                    
                    showFileUploadProgress(file.name, 60);
                    showFileUploadProgress(file.name, 80);
                    
                    // Show conversion result
                    if (convertedFile.name !== file.name) {
                        showConversionResult(file.name, convertedFile.name);
                    }
                    
                    return convertedFile;
                } catch (error) {
                    console.warn('File conversion failed, using original file:', error);
                    showConversionError(file.name);
                    return file;
                }
            }
            
            return file;
        };

        // Enhanced file validation
        const ALLOWED_FILE_TYPES = {
            'image/': ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml'],
            'audio/': ['audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/mp4'],
            'video/': ['video/mp4', 'video/webm', 'video/ogg'],
            'application/': ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'],
            'text/': ['text/plain', 'text/csv', 'text/markdown', 'application/x-tex']
        };

        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

        function validateFileType(file) {
            // Check file size
            if (file.size > MAX_FILE_SIZE) {
                return { valid: false, error: `File size (${formatFileSize(file.size)}) exceeds maximum allowed size (${formatFileSize(MAX_FILE_SIZE)})` };
            }
            
            // Check file type
            const fileType = file.type;
            const fileName = file.name.toLowerCase();
            
            // Check MIME type
            for (const [category, allowedTypes] of Object.entries(ALLOWED_FILE_TYPES)) {
                if (fileType.startsWith(category) && allowedTypes.includes(fileType)) {
                    return { valid: true };
                }
            }
            
            // Check file extension as fallback
            const allowedExtensions = ['.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.txt', '.csv', '.md', '.tex', '.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.mp3', '.wav', '.ogg', '.mp4', '.webm'];
            const hasValidExtension = allowedExtensions.some(ext => fileName.endsWith(ext));
            
            if (hasValidExtension) {
                return { valid: true };
            }
            
            return { valid: false, error: `File type "${fileType}" is not supported` };
        }
        function showFileTypeError(file, error) {
            alert(`File validation failed: ${file.name}\n\n${error}`);
        }
        function showModelFileError() {
            alert('The selected model only supports text. File upload is disabled.');
        }
        // Paste file support
        async function handlePaste(e) {
            if (!isFileModelSelected()) return;
            if (e.clipboardData && e.clipboardData.files && e.clipboardData.files.length > 0) {
                await addFilesToSelection(e.clipboardData.files);
                e.preventDefault();
            }
        }
        // Helper: is file-supporting model selected?
        function isFileModelSelected() {
            const model = MODELS[selectedModel];
            return model && model.supportsFiles;
        }
        // --- END DRAG & DROP AND PASTE ---

        // --- UI/UX: Enable/disable file input and drag-and-drop based on model ---
        function updateFileInputUI() {
            const supportsFiles = isFileModelSelected();
            elements.attachFileBtn.style.display = supportsFiles ? 'flex' : 'none';
            elements.fileInput.disabled = !supportsFiles;
            elements.fileInput.style.display = 'none'; // always hidden
            elements.imagePreviewContainer.style.display = (supportsFiles && selectedFiles.length > 0) ? 'flex' : 'none';
            
            // Show/hide file disabled message above the input area
            let fileDisabledMsg = document.getElementById('fileDisabledMsg');
            if (!supportsFiles) {
                if (!fileDisabledMsg) {
                    fileDisabledMsg = document.createElement('div');
                    fileDisabledMsg.id = 'fileDisabledMsg';
                    fileDisabledMsg.style.cssText = `
                        color: #f59e0b;
                        font-size: 0.85em;
                        margin: 0 0 0.75rem 0;
                        padding: 0.75rem;
                        background: rgba(245, 158, 11, 0.1);
                        border-radius: 0.5rem;
                        border-left: 3px solid #f59e0b;
                        display: flex;
                        align-items: center;
                        gap: 0.5rem;
                    `;
                    fileDisabledMsg.innerHTML = '<span></span><span>File upload is disabled for this model. Only text input is available.</span>';
                    // Insert before the input-and-buttons container
                    const inputContainer = elements.chatInput.closest('.input-and-buttons');
                    inputContainer.parentNode.insertBefore(fileDisabledMsg, inputContainer);
                }
            } else if (fileDisabledMsg) {
                fileDisabledMsg.remove();
            }
        }
        // Update on model change
        elements.modelSelector.addEventListener('change', () => {
            selectedModel = elements.modelSelector.value;
            updateApiKeySection();
            updateFileInputUI();
            // Clear selected files if switching to text-only model
            if (!isFileModelSelected()) {
                selectedFiles = [];
                renderImagePreviews();
            }
        });

        // --- END UI/UX ---

        // Add drag-and-drop listeners to chat area
        const chatArea = elements.chatMessages.parentNode;
        chatArea.addEventListener('dragenter', handleDragEnter);
        chatArea.addEventListener('dragover', handleDragOver);
        chatArea.addEventListener('dragleave', handleDragLeave);
        chatArea.addEventListener('drop', handleDrop);
        // Add paste listener to chat input
        elements.chatInput.addEventListener('paste', handlePaste);
        
        // Add scroll listener to save scroll position
        elements.chatMessages.addEventListener('scroll', debounce(saveScrollPosition, CONFIG.SCROLL_DEBOUNCE));



        // --- Code Block Popup Modal Logic ---

        // --- Modal Show/Hide Logic ---
        const codeModalOverlay = document.getElementById('codeModalOverlay');
        const codeModalContent = document.getElementById('codeModalContent');
        const codeModalTitle = document.getElementById('codeModalTitle');
        const codeModalClose = document.getElementById('codeModalClose');
        const codeModalCopyBtn = document.getElementById('codeModalCopyBtn');
        function showCodeModal(code, lang) {
            if (lang === 'project-structure') {
                codeModalTitle.innerHTML = `<span style='margin-right:0.4em;'></span>Project Structure`;
                codeModalContent.textContent = code;
                codeModalContent.className = '';
            } else {
                codeModalTitle.textContent = lang ? `Code (${lang})` : 'Code';
                codeModalContent.textContent = code;
                codeModalContent.className = `language-${lang}`;
                if (window.Prism) Prism.highlightElement(codeModalContent);
            }
            codeModalOverlay.classList.add('visible');
        }
        function hideCodeModal() {
            codeModalOverlay.classList.remove('visible');
        }
        codeModalClose.addEventListener('click', hideCodeModal);
        codeModalOverlay.addEventListener('click', (e) => { if (e.target === codeModalOverlay) hideCodeModal(); });
        codeModalCopyBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(codeModalContent.textContent);
            codeModalCopyBtn.textContent = 'Copied!';
            setTimeout(() => { codeModalCopyBtn.textContent = 'Copy'; }, CONFIG.COPY_FEEDBACK_DELAY);
        });

        // --- Attach event listeners to code block buttons after rendering ---
        function attachCodeBlockButtonListeners(container) {
            // Remove existing listeners first to prevent accumulation
            container.querySelectorAll('.show-code-btn').forEach(btn => {
                // Clone the button to remove all event listeners
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);
            });
            
            // Add new listeners
            container.querySelectorAll('.show-code-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const codeBlock = this.closest('.code-block');
                    if (codeBlock) {
                        const codeElement = codeBlock.querySelector('code');
                        const lang = codeElement.className.replace('language-', '');
                        const code = codeElement.textContent;
                        showCodeModal(code, lang);
                    }
                });
            });
        }

        // --- Marked.js options for better formatting (Gemini/GPT style) ---
        if (window.marked) {
            marked.setOptions({
                breaks: true,
                gfm: true,
                headerIds: false,
                mangle: false,
                highlight: function(code, lang) {
                    if (window.Prism && Prism.languages[lang]) {
                        return Prism.highlight(code, Prism.languages[lang], lang);
                    }
                    return code;
                }
            });
        }

        // --- AI Customization Functions ---

        // Load customization from localStorage
        function loadCustomization() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.CUSTOMIZATION);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    aiCustomization = { ...AI_CUSTOMIZATION, ...parsed };
                }
            } catch (error) {
                console.warn('Failed to load customization:', error);
            }
        }

        // Save customization to localStorage
        function saveCustomization() {
            try {
                localStorage.setItem(STORAGE_KEYS.CUSTOMIZATION, JSON.stringify(aiCustomization));
            } catch (error) {
                console.warn('Failed to save customization:', error);
            }
        }

        // Generate detailed system prompt based on customization
        function generateSystemPrompt() {
            let prompt = "You are a helpful AI assistant. ";
            
            // Add user name if specified
            if (aiCustomization.userName) {
                prompt += `The user's name is ${aiCustomization.userName}. Always address them by their name when appropriate and maintain a personal connection. `;
            }
            
            // Add user profession if specified
            if (aiCustomization.userProfession) {
                const profession = aiCustomization.userProfession.toLowerCase();
                if (profession.includes('developer') || profession.includes('programmer') || profession.includes('engineer')) {
                    prompt += `The user is a ${aiCustomization.userProfession}. Provide technical, code-focused responses with best practices, debugging tips, and industry standards. Use technical terminology appropriately and suggest modern development tools and frameworks. `;
                } else if (profession.includes('student') || profession.includes('learner')) {
                    prompt += `The user is a ${aiCustomization.userProfession}. Provide educational, step-by-step explanations with examples. Break down complex concepts into digestible parts and encourage learning through practice. `;
                } else if (profession.includes('designer') || profession.includes('creative')) {
                    prompt += `The user is a ${aiCustomization.userProfession}. Focus on visual design principles, user experience, creativity, and aesthetic considerations. Provide inspiration and practical design advice. `;
                } else if (profession.includes('writer') || profession.includes('content')) {
                    prompt += `The user is a ${aiCustomization.userProfession}. Emphasize writing techniques, storytelling, content strategy, and effective communication. Provide writing tips and creative inspiration. `;
                } else if (profession.includes('business') || profession.includes('manager') || profession.includes('executive')) {
                    prompt += `The user is a ${aiCustomization.userProfession}. Focus on business strategy, leadership, efficiency, and practical solutions. Provide actionable insights and professional advice. `;
                } else if (profession.includes('teacher') || profession.includes('educator')) {
                    prompt += `The user is a ${aiCustomization.userProfession}. Provide pedagogical approaches, teaching strategies, and educational content development. Focus on effective communication and learning outcomes. `;
                } else {
                    prompt += `The user is a ${aiCustomization.userProfession}. Tailor responses to their professional context and provide relevant industry insights. `;
                }
            }
            
            // Add AI traits with specific behavioral instructions
            if (aiCustomization.aiTraits.length > 0) {
                const traitInstructions = aiCustomization.aiTraits.map(trait => {
                    switch(trait) {
                        case 'chatty':
                            return 'be conversational and engaging, use casual language, ask follow-up questions, and maintain a friendly dialogue';
                        case 'witty':
                            return 'use humor, clever wordplay, and light-hearted responses while staying helpful and informative';
                        case 'straight-shooting':
                            return 'be direct, honest, and to-the-point. Avoid unnecessary fluff and give clear, actionable advice';
                        case 'encouraging':
                            return 'be supportive and motivational. Celebrate progress, acknowledge effort, and build confidence';
                        case 'gen-z':
                            return 'use contemporary language, current trends, and relatable examples. Be culturally aware and use modern expressions';
                        case 'skeptical':
                            return 'question assumptions, present alternative viewpoints, and encourage critical thinking. Be analytical and thorough';
                        case 'traditional':
                            return 'use formal language, respect established conventions, and provide conservative, well-tested approaches';
                        case 'forward-thinking':
                            return 'focus on innovation, emerging trends, and future possibilities. Suggest cutting-edge solutions and forward-looking strategies';
                        case 'poetic':
                            return 'use creative language, metaphors, and expressive descriptions. Make responses more artistic and emotionally resonant';
                        case 'technical':
                            return 'use precise terminology, provide detailed technical explanations, and focus on accuracy and depth';
                        case 'casual':
                            return 'use relaxed, informal language and create a comfortable, approachable communication style';
                        case 'formal':
                            return 'use professional language, proper structure, and maintain a serious, business-like tone';
                        default:
                            return trait;
                    }
                });
                prompt += `Communication style: ${traitInstructions.join(', ')}. `;
            }
            
            // Add user context
            if (aiCustomization.userContext) {
                prompt += `Additional context: ${aiCustomization.userContext}. Use this information to provide more relevant and personalized responses. `;
            }
            
            prompt += "Provide helpful, accurate, and personalized responses that match the specified communication style and user context.";
            return prompt;
        }

        // Open customization modal
        function openCustomizationModal() {
            // Populate form with current values
            document.getElementById('userNameInput').value = aiCustomization.userName || '';
            document.getElementById('userProfessionInput').value = aiCustomization.userProfession || '';
            document.getElementById('userContextInput').value = aiCustomization.userContext || '';
            
            // Set trait checkboxes
            document.querySelectorAll('.trait-option input').forEach(checkbox => {
                checkbox.checked = aiCustomization.aiTraits.includes(checkbox.value);
            });
            
            // Show modal
            document.getElementById('customizationModal').classList.add('visible');
        }

        // Save customization from modal
        async function saveCustomizationFromModal() {
            const saveBtn = document.getElementById('customizationSaveBtn');
            const btnText = saveBtn.querySelector('.btn-text');
            const btnLoading = saveBtn.querySelector('.btn-loading');
            
            // Show loading state
            saveBtn.classList.add('loading');
            btnText.style.display = 'none';
            btnLoading.style.display = 'flex';
            
            try {
                // Get values from form
                aiCustomization.userName = document.getElementById('userNameInput').value.trim();
                aiCustomization.userProfession = document.getElementById('userProfessionInput').value.trim();
                aiCustomization.userContext = document.getElementById('userContextInput').value.trim();
                
                // Get selected traits
                aiCustomization.aiTraits = [];
                document.querySelectorAll('.trait-option input:checked').forEach(checkbox => {
                    aiCustomization.aiTraits.push(checkbox.value);
                });
                
                // Save to localStorage
                saveCustomization();
                
                // Simulate a brief delay for better UX
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Close modal
                document.getElementById('customizationModal').classList.remove('visible');
                
                // Update summary display
                updateCustomizationSummary();
                
                // Show success message
                showNotification('AI customization saved successfully!', 'success');
            } catch (error) {
                console.error('Error saving customization:', error);
                showNotification('An error occurred while saving customization. Please try again.', 'error');
            } finally {
                // Hide loading state
                saveBtn.classList.remove('loading');
                btnText.style.display = 'block';
                btnLoading.style.display = 'none';
            }
        }

        // Show notification
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
                color: white;
                border-radius: 8px;
                padding: 12px 16px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 3000);
        }

        // Add customization event listeners
        document.getElementById('openCustomizationBtn').addEventListener('click', openCustomizationModal);
        document.getElementById('customizationModalClose').addEventListener('click', () => {
            document.getElementById('customizationModal').classList.remove('visible');
        });
        document.getElementById('customizationCancelBtn').addEventListener('click', () => {
            document.getElementById('customizationModal').classList.remove('visible');
        });
        document.getElementById('customizationSaveBtn').addEventListener('click', saveCustomizationFromModal);

        // Update customization summary display
        function updateCustomizationSummary() {
            const summaryElement = document.getElementById('customizationSummary');
            if (!summaryElement) return;
            
            const hasCustomization = aiCustomization.userName || 
                                   aiCustomization.userProfession || 
                                   aiCustomization.aiTraits.length > 0 || 
                                   aiCustomization.userContext;
            
            if (hasCustomization) {
                summaryElement.textContent = 'Customized';
            } else {
                summaryElement.textContent = 'Customize AI';
            }
        }

        // Load customization on startup
        loadCustomization();
        updateCustomizationSummary();

        // Add event listener for quick customize button
        document.getElementById('quickCustomizeBtn').addEventListener('click', openCustomizationModal);
    </script>
</body>
</html>